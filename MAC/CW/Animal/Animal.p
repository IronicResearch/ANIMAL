(* ANIMAL for the Macintosh. *)(* Copyright 1991 Dave Milici and Penguin Associates. *)(* Adapted from Mac Turbo v1.1 Pascal to Think Pascal v4.0. *)(* Adapted from Think Pascal v4.0 to CodeWarrior Pascal v11.0. *)program ANIMAL;(* Think Pascal complier directives: *){$SETC THINK_PASCAL = 0}{$SETC THINK_DEBUG = 0}(* Differences between Think Pascal and Turbo Pascal: *)(* no include files; use "un-compiled" units instead *)(* no "+" operator for strings; use Concat procedure instead *)(* no bitwise AND/OR operators; use BitAnd/BitOr procedures instead *)(* Resource file specified in Think Pascal IDE Run Options *)(* CodeWarrior Pascal compiler directives: *){$SETC CODEWARRIOR_PASCAL = 1}{$SETC SYSTEM75_NEWLIBS = 1}(* Differences between CodeWarrior Pascal and Think Pascal: *)(* Use CodeWarrior IDE Edit | Project Settings | Language Settings | Pascal *)(* Turbo Pascal IO compatibility option on *)(* ANS Pascal language conformance off for allowing "_" in symbols *)(* Default Mac Toolbox Libraries for Pascal use "new" System 7.5 names. *)(* Either re-compile Pascal libraries with "OLDROUTINENAMES = 1",(* Or use wrapper functions to translate from "old" API names to "new" APIs. *)(* Animal feature switches: *){$SETC ANIMAL_PLOT = 0}			(* for point-plotter *){$SETC DEBUG_SPLINE = 0}		(* for spline computation dump *){$SETC ANIMAL_RGB = 1}			(* for RGB Light Source *){$SETC ANIMAL_THINGM = 1}		(* for ThingM *){$SETC DEBUG_CONSOLE = 0}		(* for text console tracer messages *){$IFC THINK_PASCAL}{$I-}		(* no auto-initialize Mac OS toolbox functions *)(* Think Pascal Units: *)uses		Sane, 			(* Standard Apple Numeric Environment   *)		Types,			(* Mac OS memory data types             *)		OSEvents,		(* Mac OS interface routines            *)		Packages, 		(* Mac OS packaged functions            *)		Serial,			(* Mac OS serial routines *)		ThinkCrt,		(* Think Pascal console library *)		ThinkStr,		(* Think Pascal string library *)		SIOX,			(* serial IO shell routines *)	{$IFC ANIMAL_RGB}		RGBIO,			(* RGB Light Source interface routines *)	{$ENDC}		Mcpu;			(* Motion Control interface routines    *){$ENDC}{$IFC CODEWARRIOR_PASCAL}(* CodeWarrior Pascal Units: *)USES	Types, 		Memory, 		(* HLock *)        QuickDraw, 		OSUtils, 		SegLoad, 		Fonts, 		Windows, 		Menus, 		TextEdit, 		Dialogs,        Processes,        Events,         QuickDrawText,        Controls, 		(* SetCtlValue *)        TextUtils, 		(* GetString *)        ToolUtils, 		(* BitAnd *)        Devices, 		(* OpenDeskAcc *)        StandardFile, 	(* SFGetFile *)        TurboCRT,		(* Turbo Pascal style console extensions *)        TurboStr,		(* Turbo Pascal style string conversions *)        TIMEX,			(* timing routines *)        SIO,			(* Serial interface routines *)        MCPU,			(* Motion Control interface routines *)	{$IFC ANIMAL_RGB}		RGBIO,			(* RGB Light Source interface routines *)	{$ENDC}	{$IFC ANIMAL_THINGM}		THINGM,			(* ThingM interface routines *)	{$ENDC}		GLOBAL;			(* Animal Global variables *){$ENDC}{$IFC SYSTEM75_NEWLIBS}       (* CodeWarrior patches for "OldRoutineNames": *)PROCEDURE GetDItem(theDialog: DialogRef; itemNo: INTEGER; VAR itemType: INTEGER; VAR item: Handle; VAR box: Rect);begin	GetDialogItem(theDialog, itemNo, itemType, item, box);end;PROCEDURE SetIText(item: Handle; text: ConstStr255Param);begin	SetDialogItemText(item, text);end;PROCEDURE SelIText(theDialog: DialogRef; itemNo: INTEGER; strtSel: INTEGER; endSel: INTEGER);begin	SelectDialogItemText(theDialog, itemNo, strtSel, endSel);end;PROCEDURE GetIText(item: Handle; VAR text: Str255);begin	GetDialogItemText(item, text);end;PROCEDURE DisposDialog(theDialog: DialogRef);begin	DisposeDialog(theDialog);end;PROCEDURE SetCtlValue(theControl: ControlRef; theValue: INTEGER);begin	SetControlValue(theControl, theValue);end;PROCEDURE SetCTitle(theControl: ControlRef; title: ConstStr255Param);begin	SetControlTitle(theControl, title);end;PROCEDURE GetItem(theMenu: MenuRef; item: INTEGER; VAR itemString: Str255);begin	GetMenuItemText(theMenu, item, itemString);end;PROCEDURE AddResMenu(theMenu: MenuRef; theType: ResType);begin	AppendResMenu(theMenu, theType);end;{$ENDC}		(* CODEWARRIOR_PASCAL *)(* Think Pascal patches for Turbo Pascal extensions: *)	const		CR = char($0D);		LF = char($0A);		BS = char($08);		TAB = char($09);		ESC = char($1B);(* Standard Apple MPW Pascal program for Macintosh begins here: *)(* Adapted from Apple Developer Program example included with Turbo Pascal for Mac. *)	const		MenuCnt = 7;    { total # of menus                   }		ApplMenu = 1000;    { resource ID of Apple Menu          }		FileMenu = 1010;    { resource ID of File Menu           }		EditMenu = 1020;    { resource ID of Edit Menu           }		RunnMenu = 1030;    { Run Menu                           }		OverMenu = 1040;    { Overide Menu                       }		UtilMenu = 1050;    { Utilities Menu                     }		SpecMenu = 1060;    { Special Menu                       }		AM = 1;    { index into MenuList for Apple Menu }		FM = 2;    { File Menu                          }		EM = 3;    { Edit Menu                          }		RM = 4;    { Run Menu                           }		OM = 5;    { Overide Menu                       }		UM = 6;    { Utilities Menu                     }		SM = 7;    { Special Menu                       }		MainID = 1000;    { resource ID for MainWindow         }		AboutID = 1000;    { resource ID for dialog box         }		Text1ID = 1000;    { resource IDs for 'About...' text   }		Text2ID = 1001;		Text3ID = 1002;	type		PtrInteger = ^integer;		PtrString = ^str255;		CursorList = array[IBeamCursor..WatchCursor] of CursHandle;	var		Finished: Boolean;	         { used to terminate the program }		Ticks: Longint;	         { keeps track of time }		TV, TH: Integer;	         { location of text }		theEvent: EventRecord;      { event passed from operating system }  { Screen stuff}		DragArea: Rect;	{ defines area where window can be dragged in }		GrowArea: Rect;	{ defines area to which a window's size can change }		ScreenArea: Rect;	{ defines screen dimensions }		CursList: CursorList;   { used to hold cursor handles }  { Menu stuff}		MenuList: array[1..MenuCnt] of MenuHandle;  { holds menu info }  { Window stuff }		MainPtr: WindowPtr;        { pointer to main window        }		MainRec: WindowRecord;     { holds data for main window    }		MainPeek: WindowPeek;       { pointer to MainRec            }		ScreenPort: GrafPtr;          { pointer to entire screen      }		FrontWindow: WindowPtr;        { pointer to active window      }{   *********   items in User Dialogs      *********** }	const		BtnItem = 4;      (* button item type *)		ChkItem = 5;      (* check box item type *)		RadItem = 6;      (* radio button item type *)		TextItem = 16;    (* edit text item type *)	var		The_Dialog: DialogPtr;         (* dialog box *)		The_Item: Integer;             (* dialog item *)		The_Type: Integer;             (* item type *)		The_ItemHdl: Handle;           (* general item handle *)		The_ItemBox: Rect;             (* item location coordinates *)		The_BtnHdl,                     (* button item handle *)		The_ChkHdl,                     (* check box handle *)		The_RadHdl,                     (* radio button handle *)		The_TextHdl: Handle;           (* text item handle *){ 	********** Screen support routines. **********  }{$S WindSeg}(* ClearWindow clears window, draws grow stuff, sets location *)	procedure ClearWindow (WPtr: WindowPtr);		var			TRect: Rect;	begin		if (WPtr = MainPtr) and (Wptr = FrontWindow) then			begin				EraseRect(WPtr^.portRect);            { clear rect area of window   }				DrawGrowIcon(WPtr);                   { draw grow icon              }				TH := 5;				TV := 12;                    { set text loc to upper left  }				TextFont(Monaco);                    { select even-spaced font     }				TextSize(9);			end	end; (* DrawStr moves to text location and writes out Str *)	procedure DrawStr (Str: string);	begin		MoveTo(TH, TV);                        { move to current text location }		DrawString(Str);                      { write on screen               }		TH := TH + StringWidth(Str)           { advance location to end of str}	end;	(* 'Draw' end of line, as in Writeln. *)	procedure Drawln;	begin		TH := 5;                             (* 1st column for X *)		TV := TV + 12;                       (* next row for Y *)		MoveTo(TH, TV);                     (* move cursor there *)	end;	{ DoOutlineControl: draw bold outline around a control. }	PROCEDURE DoOutlineControl (myControl: UNIV ControlHandle);		VAR			myOval:				Integer;			myRect:				Rect;			origPen:				PenState;			origPort:				GrafPtr;	BEGIN		IF myControl <> NIL THEN			BEGIN				GetPort(origPort);				SetPort(myControl^^.contrlOwner);				GetPenState(origPen);				PenNormal;				myRect := myControl^^.contrlRect;				InsetRect(myRect, -4, -4);				myOval := ((myRect.bottom - myRect.top) DIV 2) + 2;				(* IF (myControl^^.contrlHilite = 0) THEN					PenPat(qd.gray)				ELSE					PenPat(qd.black); *)				PenSize(3, 3);				FrameRoundRect(myRect, myOval, myOval);				SetPenState(origPen);				SetPort(origPort);			END;	END;{ DoDefaultButton: draw bold outline around default button in a dialog. }	PROCEDURE DoDefaultButton (myDialog: DialogPtr);		VAR			myType:				Integer;			myHand:				Handle;			myRect:				Rect;	BEGIN		GetDialogItem(myDialog, Ok, myType, myHand, myRect);		DoOutlineControl(myHand);	END;(*************************** Animal stuff *******************************){$S AnimalSeg}	const		MFN = 1;            (* File New menu *)		MFO = 2;            (* File Open *)		MFS = 4;            (* File Save *)		MFA = 5;            (* File Save As *)		MFC = 6;            (* File Close *)		MFQ = 8;            (* File Quit *)		MEU = 1;            (* Edit Undo menu *)		MEX = 3;            (* Edit Cut *)		MEC = 4;            (* Edit Copy *)		MEV = 5;            (* Edit Paste *)		MED = 6;            (* Edit Clear *)		MEF = 8;            (* Edit Frame Count *)		MEA = 9;            (* Edit Axis Positions *)		MET = 10;           (* Edit Total Counters *)		MRC = 1;            (* Run Camera menu *)		MRP = 2;            (* Run Projector *)		MRS = 3;            (* Run Sequencer *)		MRM = 5;            (* Run Stop Motion *)		MRG = 6;            (* Run Go Motion *)		MRL = 7;            (* Run Continuous Motion *)		MOI = 1;            (* Overide Init menu *)		MOR = 2;            (* Overide Run *)		MOK = 3;            (* Overide Kill *)		MOS = 4;            (* Overide Status *)		MOP = 5;            (* Overide Position *)		MOM = 7;            (* Overide Move *)		MOG = 8;            (* Overide Goto *)		MOJ = 9;            (* Overide Jog *)		MOL = 10;           (* Overide Limit *)		MOZ = 11;           (* Overide Zero *)		MUI = 1;            (* Utility Install *)		MUM = 2;            (* Utility Motor Speed *)		MUU = 3;            (* Utility User Units *){$IFC ANIMAL_PLOT}		MSP = 1;            (* Special Point-Plotter *)		MSI = 2;            (* Special Interpolation *)		MSC = 3;            (* Special CAD Import *)		MST = 4;            (* Special Text Export *){$ENDC}{$IFC ANIMAL_RGB}		MSD = 1;			(* Special RGB Direct *)		MSP = 2;			(* Special RGB Program *)		MSR = 3;			(* Special RGB Run *)		MSC = 4;			(* Special RGB Color Table *){$ENDC}		PFrmId = 1021;      (* Preset Frame Count dialog *)		AxisId = 1022;      (* Axis Position dialog *)		CamId = 1031;       (* Camera dialog resource ID *)		PrjId = 1032;       (* Projector dialog *)		SeqId = 1033;       (* Sequencer dialog *)		FrmId = 1034;       (* Frame Count dialog *)		StopId = 1035;      (* Stop Motion dialog *)		InitId = 1041;      (* Init dialog *)		RunId = 1042;      (* Run dialog *)		KillId = 1043;      (* Kill dialog *)		StatId = 1044;      (* Status dialog *)		PosnId = 1045;      (* Position dialog *)		MoveId = 1046;      (* Move dialog *)		GotoId = 1047;      (* Goto dialog *)		JogId = 1048;      (* Jog dialog *)		LimId = 1049;      (* Limit switch dialog *)		ZeroId = 1140;      (* Zero position dialog *)		AmapId = 1051;      (* Axis Map dialog *)		MspdId = 1052;      (* Motor Speeds dialog *)		UnitId = 1053;      (* User Units dialog *)		RgbId = 3010;		(* RGB direct IO dialog *)		RgbPgmId = 3020;	(* RGB program dialog *)		RgbRunId = 3030;	(* RGB run dialog *)		ColorId = 3040;		(* RGB color table dialog *)	const		CX = 1;                             (* camera axis *)		PX = 2;                             (* projector axis *){$IFC ANIMAL_RGB}	const		RX = 3;						(* red axis *)		GX = 4;						(* green axis *)		BX = 5;						(* blue axis *)(* RGB light source data: *)	var		RGB_Color_Indexed: boolean;		RGB_Sequenced: boolean;		RGB_Buf: array[1..Max_Points] of array[1..3] of integer;{$ENDC}(********** MCPU motion control routines **********)	var		Debugged: Boolean;     (* debugging flag *)(* Pass along echoed input debugging status to MCPU library routines. *)	procedure SetSioEcho;	begin{$IFC DEBUG_CONSOLE}{$ENDC}	end;(* Input a character from ThingM and optionally echo out the Mac console. *)	procedure InSioEcho (var Ch: Char);	begin{$IFC DEBUG_CONSOLE}		InSio(Ch);		if Debugged then			Write(Ch);{$ENDC}	end;(* Get special event as input from ThingM to serial port. *)	procedure GetSpecialEvent;		var			InStatus: Boolean;			Ch: Char;	begin{$IFC DEBUG_CONSOLE}		InSioSt(InStatus);		if InStatus then			InSioEcho(Ch);{$ENDC}	end;(***** Program specifics *****){$S InitSeg}(* Initialize all Animal stuff. *)	procedure Init_Program_Stuff;		var			I: integer;	begin		(* assign Animal axes to Camera and Projector *)		With AA [CX] Do                        (* camera axis *)		       begin		       A.Name := 'Camera';		       M.AccelSt := True;		       M.LowSpd  := 0;		       M.HighSpd := 334;		       M.RampCnt := 50;		       K.Kscale  := 1.0;		       K.DP      := 1;		       K.Units   := 'Frames';		       R.AccelSt := True;		       R.Min_LowSpd  := 0;		       R.Max_HighSpd := 3.34;		       R.Max_RampCnt := 50;		       end;		With AA [PX] Do                        (* projector axis *)		       begin		       A.Name := 'Projector';		       M.AccelSt := True;		       M.LowSpd  := 0;		       M.HighSpd := 334;		       M.RampCnt := 50;		       K.Kscale  := 1.0;		       K.DP      := 1;		       K.Units   := 'Frames';		       R.AccelSt := True;		       R.Min_LowSpd  := 0;		       R.Max_HighSpd := 3.34;		       R.Max_RampCnt := 50;		       end;		       		(* enable/disable debug tracers *)		       		Debugged := False;		SetSioEcho;		(* reset serial interface for MCPU *)		ResetSio;{$IFC ANIMAL_RGB}		(* reset serial interface for RGB Light Source *)		InitRGB;		(* init RGB data *)		RGB_Color_Indexed := FALSE;		RGB_Sequenced := TRUE;		for I := 1 to Max_Points do			begin				RGB_Buf[I][1] := 0;				RGB_Buf[I][2] := 0;				RGB_Buf[I][3] := 0;			end;{$ENDC}	end;{$IFC ANIMAL_RGB}{$S SegRgb}(* Display RGB Color Table in default window. *)	procedure Display_RGB_Color_Table;		var			I: integer;			S: string;	begin		DrawStr('RGB Light Source Color Table:');		Drawln;		Drawln;		for I := 1 to RGB_Max_Color_code do			begin				with RGB_Color_Table[I] do					S := StringOf((I) : 2, (Red) : 8, (Green) : 8, (Blue) : 8, Name);				DrawStr(S);				Drawln;			end;		Drawln;	end;(* RGB light source direct drive. *)	procedure Do_RGB_Direct;		const			B1 = 1;		(* Ok button item *)			B2 = 2; 		(* Cancel button *)			RD = 3;		(* Direct RGB radio item *)			RC = 4;		(* Color RGB radio item *)			SR = 5;		(* Red string item *)			SG = 6; 		(* Green string  *)			SB = 7;		(* Blue string *)			SC = 8;		(* Color string *)			TR = 9;		(* Red text item *)			TG = 10;		(* Green text *)			TB = 11;		(* Blue text *)		var			The_RadHdl: Handle;        (* radio button item handle *)			The_TextHdl: Handle;       (* text item handle *)			The_Text: Str255;          (* text string *)			Dialog_Status: boolean;	(* ok/cancel *)		procedure Update_RGB_Dialog;		begin			The_Text := IntToStr(RGB_Red);			GetDItem(The_Dialog, SR, The_Type, The_TextHdl, The_ItemBox);			SetIText(The_TextHdl, The_Text);			if (not RGB_Color_Indexed) then				SelIText(The_Dialog, SR, 0, Length(The_Text));			The_Text := IntToStr(RGB_Green);			GetDItem(The_Dialog, SG, The_Type, The_TextHdl, The_ItemBox);			SetIText(The_TextHdl, The_Text);			The_Text := IntToStr(RGB_Blue);			GetDItem(The_Dialog, SB, The_Type, The_TextHdl, The_ItemBox);			SetIText(The_TextHdl, The_Text);			The_Text := IntToStr(RGB_Color);			GetDItem(The_Dialog, SC, The_Type, The_TextHdl, The_ItemBox);			SetIText(The_TextHdl, The_Text);			if (RGB_Color_Indexed) then				SelIText(The_Dialog, SC, 0, Length(The_Text));			The_Text := IntToStr(RGB_Color_Table[RGB_Color].Red);			GetDItem(The_Dialog, TR, The_Type, The_TextHdl, The_ItemBox);			SetIText(The_TextHdl, The_Text);			The_Text := IntToStr(RGB_Color_Table[RGB_Color].Green);			GetDItem(The_Dialog, TG, The_Type, The_TextHdl, The_ItemBox);			SetIText(The_TextHdl, The_Text);			The_Text := IntToStr(RGB_Color_Table[RGB_Color].Blue);			GetDItem(The_Dialog, TB, The_Type, The_TextHdl, The_ItemBox);			SetIText(The_TextHdl, The_Text);		end;	begin		Display_RGB_Color_Table;		The_Dialog := GetNewDialog(RgbId, nil, Pointer(-1));   (* init data entry strings *)		Update_RGB_Dialog;   (* init radio button item *)		if (RGB_Color_Indexed) then			The_Item := RC		else			The_Item := RD;		GetDItem(The_Dialog, The_Item, The_Type, The_RadHdl, The_ItemBox);		SetCtlValue(ControlHandle(The_RadHdl), 1);		DoDefaultButton(The_Dialog);		Dialog_Status := TRUE;		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			case The_Type of				TextItem: 					begin						GetIText(The_ItemHdl, The_Text);						case The_Item of							SR: 								RGB_Red := MaxByte(StrToInt(The_Text));							SG: 								RGB_Green := MaxByte(StrToInt(The_Text));							SB: 								RGB_Blue := MaxByte(StrToInt(The_Text));							SC: 								RGB_Color := MaxColor(StrToInt(The_Text));						end;					end;				RadItem: 					begin						SetCtlValue(ControlHandle(The_RadHdl), 0);						SetCtlValue(ControlHandle(The_ItemHdl), 1);						The_RadHdl := The_ItemHdl;						case The_Item of							RD: 								begin									RGB_Color_Indexed := FALSE;									SelIText(The_Dialog, SR, 0, $7FFF);								end;							RC: 								begin									RGB_Color_Indexed := TRUE;									SelIText(The_Dialog, SC, 0, $7FFF);								end;						end;					end;				BtnItem: 					case The_Item of						B1: 							begin								if (RGB_Color_Indexed) then									OutColor(RGB_Color)								else									OutRGB(RGB_Red, RGB_Green, RGB_Blue);								Update_RGB_Dialog;								Dialog_Status := TRUE;							end;						B2: 							Dialog_Status := FALSE;					end;			end;		until (The_Type = BtnItem) and (Dialog_Status = FALSE);		DisposDialog(The_Dialog);(* execute dialog data *)		if (Dialog_Status) then			if (RGB_Color_Indexed) then				OutColor(RGB_Color)			else				OutRGB(RGB_Red, RGB_Green, RGB_Blue);	end;(* RGB light source programming. *)	procedure Do_RGB_Program;		const			B1 = 1;		(* Ok button item *)			B2 = 2; 		(* Cancel button *)			SF0 = 6;		(* Frame 0 string iyem *)			SC0 = 7;		(* Color 0 string *)			TR0 = 8;		(* RGB 0 text *)			SF1 = 9;		(* Frame 1 string *)			SC1 = 10;	(* Color 1 string *)			TR1 = 11;	(* RGB 1 text *)		var			The_TextHdl: Handle;       (* text item handle *)			The_Text: Str255;          (* text string *)			Dialog_Status: boolean;	(* ok/cancel *)			Frame0, Frame1: integer;	(* frame start/end *)			Color0, Color1: integer;		(* color start/end *)			Red0, Green0, Blue0: integer;			Red1, Green1, Blue1: integer;			F: integer;	begin(* get RGB transition program data *)		if (not AA[RX].P.Spec) then			with AA[RX] do				begin					P.Spec := TRUE;					P.StartFrame := 1;					P.EndFrame := Preset_Count;					P.StartPoint := RGB_Color;					P.EndPoint := RGB_Color;				end;		with AA[RX] do			begin				Frame0 := P.StartFrame;				Frame1 := P.EndFrame;				Color0 := Round(P.StartPoint);				Color1 := Round(P.EndPoint);			end;		Red0 := RGB_Color_Table[Color0].Red;		Green0 := RGB_Color_Table[Color0].Green;		Blue0 := RGB_Color_Table[Color0].Blue;		Red1 := RGB_Color_Table[Color1].Red;		Green1 := RGB_Color_Table[Color1].Green;		Blue1 := RGB_Color_Table[Color1].Blue;		The_Dialog := GetNewDialog(RgbPgmId, nil, Pointer(-1));   (* init data entry strings *)		The_Text := IntToStr(Frame0);		GetDItem(The_Dialog, SF0, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(Color0);		GetDItem(The_Dialog, SC0, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, SC0, 0, Length(The_Text));		The_Text := Concat(IntToStr(Red0), ' - ', IntToStr(Green0), ' - ', IntToStr(Blue0));		GetDItem(The_Dialog, TR0, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(Frame1);		GetDItem(The_Dialog, SF1, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(Color1);		GetDItem(The_Dialog, SC1, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := Concat(IntToStr(Red1), ' - ', IntToStr(Green1), ' - ', IntToStr(Blue1));		GetDItem(The_Dialog, TR1, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			case The_Type of				TextItem: 					begin						GetIText(The_ItemHdl, The_Text);						case The_Item of							SF0: 								Frame0 := StrToInt(The_Text);							SF1: 								Frame1 := StrToInt(The_Text);							SC0: 								Color0 := StrToInt(The_Text);							SC1: 								Color1 := StrToInt(The_Text);						end;					end;				BtnItem: 					case The_Item of						B1: 							Dialog_Status := TRUE;						B2: 							Dialog_Status := FALSE;					end;			end;		until The_Type = BtnItem;		DisposDialog(The_Dialog);(* compute RGB transition data *)		if (Dialog_Status) then			begin				if (Frame1 > Preset_Count) then					Frame1 := Preset_Count;				Color0 := MaxColor(Color0);				Color1 := MaxColor(Color1);				Red0 := RGB_Color_Table[Color0].Red;				Green0 := RGB_Color_Table[Color0].Green;				Blue0 := RGB_Color_Table[Color0].Blue;				Red1 := RGB_Color_Table[Color1].Red;				Green1 := RGB_Color_Table[Color1].Green;				Blue1 := RGB_Color_Table[Color1].Blue;				for F := 1 to Frame0 do					begin						RGB_Buf[F][1] := Red0;						RGB_Buf[F][2] := Green0;						RGB_Buf[F][3] := Blue0;					end;				for F := Frame0 to Frame1 do					begin						RGB_Buf[F][1] := Round(Red0 + (Red1 - Red0) * F / (Frame1 - Frame0 + 1));						RGB_Buf[F][2] := Round(Green0 + (Green1 - Green0) * F / (Frame1 - Frame0 + 1));						RGB_Buf[F][3] := Round(Blue0 + (Blue1 - Blue0) * F / (Frame1 - Frame0 + 1));					end;				for F := Frame1 to Preset_Count do					begin						RGB_Buf[F][1] := Red1;						RGB_Buf[F][2] := Green1;						RGB_Buf[F][3] := Blue1;					end;				OutRGB(Red0, Green0, Blue0);	   (* put RGB transition program data *)				with AA[RX] do					begin						P.StartFrame := Frame0;						P.EndFrame := Frame1;						P.StartPoint := Color0;						P.EndPoint := Color1;					end;			end;	end;(* RGB light source transition run. *)	procedure Do_RGB_Run;		const			B1 = 1;		(* Ok button item *)			B2 = 2; 		(* Cancel button *)			SF0 = 6;		(* Frame 0 string iyem *)			SC0 = 7;		(* Color 0 string *)			TR0 = 8;		(* RGB 0 text *)			SFX = 9;		(* Frame x string *)			SCX = 10;	(* Color x string *)			TRX = 11;	(* RGB x text *)			SF1 = 12;	(* Frame 1 string *)			SC1 = 13;	(* Color 1 string *)			TR1 = 14;	(* RGB 1 text *)			RC = 15;		(* Continuous radio item *)			RS = 16;		(* Single-Frame radio item *)		var			The_RadHdl: Handle;        (* radio button item handle *)			The_TextHdl: Handle;       (* text item handle *)			The_Text: Str255;          (* text string *)			Dialog_Status: boolean;	(* ok/cancel *)			Frame0, Frame1: integer;	(* frame start/end *)			Color0, Color1: integer; 	(* color start/end *)			Red0, Green0, Blue0: integer;			Red1, Green1, Blue1: integer;			F: integer;					(* frame count *)	begin(* get RGB transition program data *)		with AA[RX] do			begin				Frame0 := P.StartFrame;				Frame1 := P.EndFrame;				Color0 := Round(P.StartPoint);				Color1 := Round(P.EndPoint);			end;		Red0 := RGB_Color_Table[Color0].Red;		Green0 := RGB_Color_Table[Color0].Green;		Blue0 := RGB_Color_Table[Color0].Blue;		Red1 := RGB_Color_Table[Color1].Red;		Green1 := RGB_Color_Table[Color1].Green;		Blue1 := RGB_Color_Table[Color1].Blue;		F := 1;(* output initial color *)		OutRGB(Red0, Green0, Blue0);		The_Dialog := GetNewDialog(RgbRunId, nil, Pointer(-1));   (* init data entry strings *)		The_Text := IntToStr(Frame0);		GetDItem(The_Dialog, SF0, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(Color0);		GetDItem(The_Dialog, SC0, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := Concat(IntToStr(Red0), ' - ', IntToStr(Green0), ' - ', IntToStr(Blue0));		GetDItem(The_Dialog, TR0, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(Frame1);		GetDItem(The_Dialog, SF1, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(Color1);		GetDItem(The_Dialog, SC1, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := Concat(IntToStr(Red1), ' - ', IntToStr(Green1), ' - ', IntToStr(Blue1));		GetDItem(The_Dialog, TR1, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(F);		GetDItem(The_Dialog, SFX, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := '---';		GetDItem(The_Dialog, SCX, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := Concat(IntToStr(RGB_Red), ' - ', IntToStr(RGB_Green), ' - ', IntToStr(RGB_Blue));		GetDItem(The_Dialog, TRX, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);   (* init radio button item *)		if (RGB_Sequenced) then			The_Item := RC		else			The_Item := RS;		GetDItem(The_Dialog, The_Item, The_Type, The_RadHdl, The_ItemBox);		SetCtlValue(ControlHandle(The_RadHdl), 1);		DoDefaultButton(The_Dialog);		F := 1;		Dialog_Status := TRUE;		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			case The_Type of				RadItem: 					begin						SetCtlValue(ControlHandle(The_RadHdl), 0);						SetCtlValue(ControlHandle(The_ItemHdl), 1);						The_RadHdl := The_ItemHdl;						case The_Item of							RS: 								RGB_Sequenced := FALSE;							RC: 								RGB_Sequenced := TRUE;						end;					end;				BtnItem: 					case The_Item of						B1:  (* OK --> execution *)							if (RGB_Sequenced) then								begin									The_Text := IntToStr(F);									GetDItem(The_Dialog, SFX, The_Type, The_TextHdl, The_ItemBox);									SetIText(The_TextHdl, The_Text);									for F := 1 to Preset_Count do										begin											SetIText(The_TextHdl, IntToStr(F));											OutRGB(RGB_Buf[F][1], RGB_Buf[F][2], RGB_Buf[F][3]);											TPDelay(32);	(* 2 ticks *)										end;									Dialog_Status := FALSE;								end							else (* single framed *)								begin									F := Succ(F);									OutRGB(RGB_Buf[F][1], RGB_Buf[F][2], RGB_Buf[F][3]);									The_Text := IntToStr(F);									GetDItem(The_Dialog, SFX, The_Type, The_TextHdl, The_ItemBox);									SetIText(The_TextHdl, The_Text);									The_Text := Concat(IntToStr(RGB_Red), ' - ', IntToStr(RGB_Green), ' - ', IntToStr(RGB_Blue));									GetDItem(The_Dialog, TRX, The_Type, The_TextHdl, The_ItemBox);									SetIText(The_TextHdl, The_Text);									if (F >= Preset_Count) then										Dialog_Status := FALSE;								end;						B2:  (* cancel *)							Dialog_Status := FALSE;					end;			end;		until (Dialog_Status = FALSE);		DisposDialog(The_Dialog);	end;(* RGB light source color table management. *)	procedure Do_RGB_Color_Table;		const			BE = 1;		(* Ok button item *)			BS = 2; 		(* Save button *)			BL = 3;		(* Load button *)			BQ = 4;		(* Quit button *)			SC = 9;		(* Color string item *)			SR = 10;		(* Red string *)			SG = 11; 	(* Green string  *)			SB = 12;		(* Blue string *)			SN = 13;		(* Name string *)		var			The_TextHdl: Handle;       (* text item handle *)			The_Text: Str255;          (* text string *)			Dialog_Status: boolean;	(* ok/cancel *)		procedure Update_Color_Table_Dialog;		begin			The_Text := IntToStr(RGB_Color);			GetDItem(The_Dialog, SC, The_Type, The_TextHdl, The_ItemBox);			SetIText(The_TextHdl, The_Text);			SelItext(The_Dialog, SC, 0, Length(The_Text));			The_Text := IntToStr(RGB_Color_Table[RGB_Color].Red);			GetDItem(The_Dialog, SR, The_Type, The_TextHdl, The_ItemBox);			SetIText(The_TextHdl, The_Text);			The_Text := IntToStr(RGB_Color_Table[RGB_Color].Green);			GetDItem(The_Dialog, SG, The_Type, The_TextHdl, The_ItemBox);			SetIText(The_TextHdl, The_Text);			The_Text := IntToStr(RGB_Color_Table[RGB_Color].Blue);			GetDItem(The_Dialog, SB, The_Type, The_TextHdl, The_ItemBox);			SetIText(The_TextHdl, The_Text);			The_Text := RGB_Color_Table[RGB_Color].Name;			GetDItem(The_Dialog, SN, The_Type, The_TextHdl, The_ItemBox);			SetIText(The_TextHdl, The_Text);		end;	begin		Display_RGB_Color_Table;		The_Dialog := GetNewDialog(ColorId, nil, Pointer(-1));   (* init data entry strings *)		Update_Color_Table_Dialog;		DoDefaultButton(The_Dialog);		Dialog_Status := TRUE;		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			case The_Type of				TextItem: 					begin						GetIText(The_ItemHdl, The_Text);						case The_Item of							SC: 								RGB_Color := MaxColor(StrToInt(The_Text));							SR: 								RGB_Color_Table[RGB_Color].Red := MaxByte(StrToInt(The_Text));							SG: 								RGB_Color_Table[RGB_Color].Green := MaxByte(StrToInt(The_Text));							SB: 								RGB_Color_Table[RGB_Color].Blue := MaxByte(StrToInt(The_Text));							SN: 								RGB_Color_Table[RGB_Color].Name := The_Text;						end;					end;				BtnItem: 					case The_Item of						BE: 							begin								OutColor(RGB_Color);								Update_Color_Table_Dialog;								Display_RGB_Color_Table;							end;						BS: 							SaveColorTable('ANIMAL.RGB');						BL: 							begin								LoadColorTable('ANIMAL.RGB');								Update_Color_Table_Dialog;								Display_RGB_Color_Table;							end;						BQ: 							Dialog_Status := FALSE;					end;			end;		until (The_Type = BtnItem) and (Dialog_Status = FALSE);		DisposDialog(The_Dialog);	end;{$ENDC}			(* ANIMAL_RGB *)(********* Overide command operations **********){$S SegOveride}(* Dialog for Initialize Motor *)	procedure Get_Init_Options;		const			IM = 4;                   (* Init Motor item *)			IL = 6;                   (* Init Low Speed item *)			IH = 8;                   (* Init High Speed item *)			IR = 10;                  (* Init Ramp Count item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)	begin		The_Dialog := GetNewDialog(InitId, nil, Pointer(-1));		The_Text := IntToStr(M.MotorNo);		GetDItem(The_Dialog, IM, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(M.LowSpd);		GetDItem(The_Dialog, IL, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(M.HighSpd);		GetDItem(The_Dialog, IH, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, IH, 0, Length(The_Text));		The_Text := IntToStr(M.RampCnt);		GetDItem(The_Dialog, IR, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					case The_Item of						IM: 							M.MotorNo := StrToInt(The_Text);						IL: 							M.LowSpd := StrToInt(The_Text);						IH: 							M.HighSpd := StrToInt(The_Text);						IR: 							M.RampCnt := StrToInt(The_Text);					end;				end;		until The_Type = BtnItem;		DisposDialog(The_Dialog);	end;(* Dialog for Run Motor *)	procedure Get_Run_Options;		const			RM = 4;                   (* Run Motor item *)			RR = 6;                   (* Run Run item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)	begin		The_Dialog := GetNewDialog(RunId, nil, Pointer(-1));		The_Text := IntToStr(M.MotorNo);		GetDItem(The_Dialog, RM, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := RealToStr(M.StepCnt, 0);		GetDItem(The_Dialog, RR, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, RR, 0, Length(The_Text));		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					case The_Item of						RM: 							M.MotorNo := StrToInt(The_Text);						RR: 							M.StepCnt := StrToReal(The_Text);					end;				end;		until The_Type = BtnItem;		DisposDialog(The_Dialog);	end;(* Dialog for Status Update *)(* Status is sampled from MCPU here. *)	procedure Get_Status_Update;		const			SM = 4;                   (* Status Motor item *)			SS = 6;                   (* Status Status item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)	begin		The_Dialog := GetNewDialog(StatId, nil, Pointer(-1));		The_Text := IntToStr(M.MotorNo);		GetDItem(The_Dialog, SM, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, SM, 0, Length(The_Text));		The_Text := '';		GetDItem(The_Dialog, SS, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			case The_Type of				TextItem: 					begin						GetIText(The_ItemHdl, The_Text);						if The_Item = SM then							M.MotorNo := StrToInt(The_Text);					end;				BtnItem: 					if The_Item = Ok then						begin							GetStat(M);{$IFC THINK_PASCAL}							The_Text := Concat(M.Stat, '...', Decode_Status(M));{$ELSEC}							The_Text := M.Stat + '...' + Decode_Status(M);{$ENDC}							GetDItem(The_Dialog, SS, The_Type, The_TextHdl, The_ItemBox);							SetIText(The_TextHdl, The_Text);						end;			end;		until (The_Type = BtnItem) and (The_Item = Cancel);		DisposDialog(The_Dialog);	end;(* Dialog for Position Update *)(* Position is sampled from MCPU here. *)	procedure Get_Position_Update;		const			PM = 4;                   (* Position Motor # item *)			PP = 6;                   (* Position Position item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)	begin		The_Dialog := GetNewDialog(PosnId, nil, Pointer(-1));		The_Text := IntToStr(M.MotorNo);		GetDItem(The_Dialog, PM, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, PM, 0, Length(The_Text));		The_Text := '';		GetDItem(The_Dialog, PP, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			case The_Type of				TextItem: 					begin						GetIText(The_ItemHdl, The_Text);						if The_Item = PM then							M.MotorNo := StrToInt(The_Text);					end;				BtnItem: 					if The_Item = Ok then						begin							GetCount(M);							The_Text := RealToStr(M.Count, 0);							GetDItem(The_Dialog, PP, The_Type, The_TextHdl, The_ItemBox);							SetIText(The_TextHdl, The_Text);						end;			end;		until (The_Type = BtnItem) and (The_Item = Cancel);		DisposDialog(The_Dialog);	end;(* Dialog for Jogging motor. *)(* MCPU operations here. *)	procedure Put_Jog_Keys;		const			JM = 4;                   (* Jog Motor item *)			JI = 5;                   (* Jog Incremental item *)			JC = 6;                   (* Jog Continuous item *)			JF = 8;                   (* Jog Forward item *)			JR = 7;                   (* Jog Reverse item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)			The_RadHdl: Handle;        (* Radio button item handle *)			Incremental_Jogging: Boolean;      (* Increment per keystroke *)			Continual_Running: Boolean;        (* Stop/Go status per keystroke *)			Quit_Jogging: Boolean;             (* Quit jog dialog status *)	begin		Incremental_Jogging := True;		Continual_Running := False;		The_Dialog := GetNewDialog(JogId, nil, Pointer(-1));		The_Text := IntToStr(M.MotorNo);		GetDItem(The_Dialog, JM, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, JM, 0, Length(The_Text));		if Incremental_Jogging then			The_Item := JI		else			The_Item := JC;		GetDItem(The_Dialog, The_Item, The_Type, The_RadHdl, The_ItemBox);		SetCtlValue(ControlHandle(The_RadHdl), 1);		DoDefaultButton(The_Dialog);		Quit_Jogging := False;		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			case The_Type of				TextItem: 					begin						GetIText(The_ItemHdl, The_Text);						if The_Item = SM then							M.MotorNo := StrToInt(The_Text);					end;				RadItem: 					begin						SetCtlValue(ControlHandle(The_RadHdl), 0);						SetCtlValue(ControlHandle(The_ItemHdl), 1);						The_RadHdl := The_ItemHdl;						case The_Item of							JI: 								Incremental_Jogging := True;							JC: 								Incremental_Jogging := False;						end;					end;				BtnItem: 					begin						case The_Item of							JF: 								M.Dir := FWD;							JR: 								M.Dir := REV;							OK: 								Quit_Jogging := False;							Cancel: 								Quit_Jogging := True;						end;						if not Quit_Jogging then							if Incremental_Jogging then								PulseM(M)							else								begin									if Continual_Running then										KillM(M)									else										RunM(M);									Continual_Running := not Continual_Running;								end;					end;			end;		until Quit_Jogging;		KillM(M);		DisposDialog(The_Dialog);	end;(* Dialog for Move Motor Distance by user units. *)	procedure Get_Move_Options;		const			RM = 4;                   (* Run Motor item *)			RR = 6;                   (* Run Run item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)			Distance: Real;            (* move distance *)	begin		Distance := 0.0;		The_Dialog := GetNewDialog(MoveId, nil, Pointer(-1));		The_Text := IntToStr(Index);		GetDItem(The_Dialog, RM, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := RealToStr(Distance, AA[Index].K.dp);		GetDItem(The_Dialog, RR, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, RR, 0, Length(The_Text));		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					case The_Item of						RM: 							if StrToInt(The_Text) in [1..Max_Axes] then								Index := StrToInt(The_Text);						RR: 							Distance := StrToReal(The_Text);					end;				end;		until The_Type = BtnItem;		DisposDialog(The_Dialog);		with AA[Index] do			begin				if The_Item = Ok then					M.StepCnt := Distance * K.Kscale				else					M.StepCnt := 0;				PrepM(M);			end;	end;(* Dialog for Goto Motor Position by user units. *)	procedure Get_Goto_Options;		const			RM = 4;                   (* Run Motor item *)			RR = 6;                   (* Run Run item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)			Destination: Real;         (* Goto Destination *)	begin		with AA[Index] do			begin				GetCount(M);				Destination := M.Count / K.Kscale;			end;		The_Dialog := GetNewDialog(GotoId, nil, Pointer(-1));		The_Text := IntToStr(Index);		GetDItem(The_Dialog, RM, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := RealToStr(Destination, AA[Index].K.dp);		GetDItem(The_Dialog, RR, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, RR, 0, Length(The_Text));		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					case The_Item of						RM: 							if StrToInt(The_Text) in [1..Max_Axes] then								Index := StrToInt(The_Text);						RR: 							Destination := StrToReal(The_Text);					end;				end;		until The_Type = BtnItem;		DisposDialog(The_Dialog);		with AA[Index] do			begin				GetCount(M);				if The_Item = OK then					M.StepCnt := Destination * K.Kscale - M.Count				else					M.StepCnt := 0;				PrepM(M);			end;	end;(* Dialog for Limit Motor *)	procedure Get_Limit_Options;		const			LM = 5;                   (* Limit Motor item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)	begin		The_Dialog := GetNewDialog(LimId, nil, Pointer(-1));		The_Text := IntToStr(Index);		GetDItem(The_Dialog, LM, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, LM, 0, Length(The_Text));		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					case The_Item of						LM: 							if StrToInt(The_Text) in [1..Max_Axes] then								Index := StrToInt(The_Text);					end;				end;		until The_Type = BtnItem;		DisposDialog(The_Dialog);	end;(* Dialog for Zero Motor Position. *)	procedure Get_Zero_Options;		const			ZM = 5;                   (* Zero Motor item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)	begin		The_Dialog := GetNewDialog(ZeroId, nil, Pointer(-1));		The_Text := IntToStr(Index);		GetDItem(The_Dialog, ZM, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, ZM, 0, Length(The_Text));		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					case The_Item of						ZM: 							if StrToInt(The_Text) in [1..Max_Axes] then								Index := StrToInt(The_Text);					end;				end;		until The_Type = BtnItem;		DisposDialog(The_Dialog);	end;(********** Frame Counters display routines **********)(* Window for running Frame Counts. *)(* Poll Status and Position updates from MCPU here. *)(* Open dialog window with initial labels and counter data. *)	procedure Get_Frame_Counts;		const			CS = 3;                   (* Camera string item *)			CT = 4;                   (* Camera Total item *)			PS = 5;                   (* Projector string item *)			PT = 6;                   (* Projector Total item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)	begin		The_Dialog := GetNewDialog(FrmId, nil, Pointer(-1));		The_Text := 'Camera Frame';		GetDItem(The_Dialog, CS, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(Camera_Total);		GetDItem(The_Dialog, CT, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := 'Projector Frame';		GetDItem(The_Dialog, PS, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(Projector_Total);		GetDItem(The_Dialog, PT, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		DoDefaultButton(The_Dialog);		ShowWindow(WindowPtr(The_Dialog));	end;(* Update counter data in window. *)	procedure Put_Frame_Counts;		const			CS = 3;                   (* Camera string item *)			CT = 4;                   (* Camera Total item *)			PS = 5;                   (* Projector string item *)			PT = 6;                   (* Projector Total item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)			The_Event: EventRecord;    (* user interruption event *)			The_CtrlHdl: Handle;       (* Button control item handle *)	begin		if The_Dialog <> nil then			begin				The_Text := IntToStr(Camera_Total);				GetDItem(The_Dialog, CT, The_Type, The_TextHdl, The_ItemBox);				SetIText(The_TextHdl, The_Text);				The_Text := IntToStr(Projector_Total);				GetDItem(The_Dialog, PT, The_Type, The_TextHdl, The_ItemBox);				SetIText(The_TextHdl, The_Text);				DoDefaultButton(The_Dialog);				ShowWindow(WindowPtr(The_Dialog));				if KeyPressed or Button then					begin						GetDItem(The_Dialog, Ok, The_Type, The_CtrlHdl, The_ItemBox);						HiliteControl(ControlHandle(The_CtrlHdl), 1);						if KeyPressed then							if ReadKey = CR then								;						GetDItem(The_Dialog, Ok, The_Type, The_CtrlHdl, The_ItemBox);						SetCTitle(ControlHandle(The_CtrlHdl), 'Go');						HiliteControl(ControlHandle(The_CtrlHdl), 0);						DoDefaultButton(The_Dialog);						repeat							ModalDialog(nil, The_Item);							GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);						until The_Type = BtnItem;						GetDItem(The_Dialog, Ok, The_Type, The_CtrlHdl, The_ItemBox);						SetCTitle(ControlHandle(The_CtrlHdl), 'Stop');					end;			end;     (* insure dialog box pointer has been created *)	end;(* Close window and release pointer. *)	procedure Trash_Frame_Counts;	begin		DisposDialog(The_Dialog);	end;(* Edit cummulative Frame Counters. *)	procedure Edit_Frame_Counts;		const			CS = 3;                   (* Camera string item *)			CT = 4;                   (* Camera Total item *)			PS = 5;                   (* Projector string item *)			PT = 6;                   (* Projector Total item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)			The_CtrlHdl: Handle;       (* control button handle *)	begin		The_Dialog := GetNewDialog(FrmId, nil, Pointer(-1));		The_Text := IntToStr(Camera_Total);		GetDItem(The_Dialog, CT, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelIText(The_Dialog, CT, 0, Length(The_Text));		The_Text := IntToStr(Projector_Total);		GetDItem(The_Dialog, PT, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		GetDItem(The_Dialog, Ok, The_Type, The_CtrlHdl, The_ItemBox);		SetCTitle(ControlHandle(The_CtrlHdl), 'Ok');		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					case The_Item of						CT: 							Camera_Total := StrToInt(The_Text);						PT: 							Projector_Total := StrToInt(The_Text);					end;				end;		until (The_Type = BtnItem);		DisposDialog(The_Dialog);	end;(* Edit preset Frame Count. *)	procedure Edit_Preset_Counts;		const			FS = 3;                   (* Frame string item *)			FX = 4;                   (* Frame Count item *)			TS = 5;                   (* Time string item *)			TX = 6;                   (* Time Frame item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)			The_CtrlHdl: Handle;       (* control button handle *)			Screen_Time: Real;         (* frame count screen time *)	begin		The_Dialog := GetNewDialog(PFrmId, nil, Pointer(-1));		The_Text := IntToStr(Preset_Count);		GetDItem(The_Dialog, FX, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelIText(The_Dialog, FX, 0, Length(The_Text));		Screen_Time := Preset_count / 24.0;		The_Text := RealToStr(Screen_Time, 2);		GetDItem(The_Dialog, TX, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					case The_Item of						FX: 							begin								Preset_Count := StrToInt(The_Text);								Screen_Time := Preset_Count / 24.0;							end;						TX: 							begin								Screen_Time := StrToReal(The_Text);								Preset_Count := Round(Screen_Time * 24.0);							end;					end;				end;		until (The_Type = BtnItem);		DisposDialog(The_Dialog);		if (Preset_Count > Max_Points) then			Preset_Count := Max_Points;	end;(* Dialog for Axis Position Cues. *)	procedure Get_Axis_Increments (var P: Parameter_Table);		const			SF = 4;                   (* Start Frame item *)			EF = 6;                   (* End Frame item *)			SP = 8;                   (* Start Position *)			EP = 10;                  (* End Position *)			ST = 12;                  (* Start Taper In *)			ET = 14;                  (* End Taper Out *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)	begin		The_Dialog := GetNewDialog(AxisId, nil, Pointer(-1));		The_Text := IntToStr(P.StartFrame);		GetDItem(The_Dialog, SF, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(P.EndFrame);		GetDItem(The_Dialog, EF, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := RealToStr(P.StartPoint, 3);		GetDItem(The_Dialog, SP, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, SP, 0, Length(The_Text));		The_Text := RealToStr(P.EndPoint, 3);		GetDItem(The_Dialog, EP, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := RealToStr(P.Accel, 1);		GetDItem(The_Dialog, ST, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := RealToStr(P.Decel, 1);		GetDItem(The_Dialog, ET, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					case The_Item of						SF: 							P.StartFrame := StrToInt(The_Text);						EF: 							P.EndFrame := StrToInt(The_Text);						SP: 							P.StartPoint := StrToReal(The_Text);						EP: 							P.EndPoint := StrToReal(The_Text);						ST: 							P.Accel := StrToReal(The_Text);						ET: 							P.Decel := StrToReal(The_Text);					end;					if P.EndFrame > Preset_Count then						Preset_Count := P.EndFrame;					P.Taper := (P.Accel + P.Decel > 0.0);				end;		until (The_Type = BtnItem);		DisposDialog(The_Dialog);	end;(********** Sequencer operations **********)(* Dialog for Camera Overide. *)	procedure Get_Camera_Options;		const			CC = 4;                   (* Camera Count item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)	begin		The_Dialog := GetNewDialog(CamId, nil, Pointer(-1));		The_Text := IntToStr(Camera_Count);		GetDItem(The_Dialog, CC, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, CC, 0, Length(The_Text));		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				GetIText(The_ItemHdl, The_Text);		until The_Type = BtnItem;		DisposDialog(The_Dialog);		Camera_Count := StrToInt(The_Text);		if The_Item = Ok then			Frame_Count := Camera_Count		else			Frame_Count := 0;	end;(* Dialog for Projector Overide. *)	procedure Get_Projector_Options;		const			PC = 4;                   (* Projector Count item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)	begin		The_Dialog := GetNewDialog(PrjId, nil, Pointer(-1));		The_Text := IntToStr(Projector_Count);		GetDItem(The_Dialog, PC, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, PC, 0, Length(The_Text));		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				GetIText(The_ItemHdl, The_Text);		until The_Type = BtnItem;		DisposDialog(The_Dialog);		Projector_Count := StrToInt(The_Text);		if The_Item = Ok then			Frame_Count := Projector_Count		else			Frame_Count := 0;	end;(* Dialog for Sequencer options. *)	procedure Get_Sequencer_Options;		const			B1 = 1;                   (* Ok button item *)			B2 = 2;                   (* Cancel button item *)			RA = 3;                   (* Alternate radio item *)			RC = 4;                   (* Camera-Step radio item *)			RP = 5;                   (* Projector-Skip radio item *)			SC = 7;                   (* Camera Count string item *)			SP = 9;                   (* Projector Count string item *)			SS = 11;                  (* Sequencer Count string item *)		var			The_RadHdl: Handle;        (* radio button item handle *)			The_TextHdl: Handle;       (* text item handle *)			The_Text: Str255;          (* text string *)	begin		The_Dialog := GetNewDialog(SeqId, nil, Pointer(-1));   (* init camera, projector, and sequencer count strings *)		The_Text := IntToStr(Camera_Cycle);		GetDItem(The_Dialog, SC, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(Projector_Cycle);		GetDItem(The_Dialog, SP, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(Sequencer_Count);		GetDItem(The_Dialog, SS, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, SS, 0, Length(The_Text));   (* init 1st radio button = item #3 for sequencer mode *)		case Sequencer of			Alternate: 				The_Item := RA;			StepCamera: 				The_Item := RC;			SkipProjector: 				The_Item := RP;			otherwise				The_Item := 0;		end;		GetDItem(The_Dialog, The_Item, The_Type, The_RadHdl, The_ItemBox);		SetCtlValue(ControlHandle(The_RadHdl), 1);		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			case The_Type of				TextItem: 					begin						GetIText(The_ItemHdl, The_Text);						case The_Item of							SC: 								Camera_Cycle := StrToInt(The_Text);							SP: 								Projector_Cycle := StrToInt(The_Text);							SS: 								Sequencer_Count := StrToInt(The_Text);						end;					end;				RadItem: 					begin						SetCtlValue(ControlHandle(The_RadHdl), 0);						SetCtlValue(ControlHandle(The_ItemHdl), 1);						The_RadHdl := The_ItemHdl;						case The_Item of							RA: 								Sequencer := Alternate;							RC: 								Sequencer := StepCamera;							RP: 								Sequencer := SkipProjector;							otherwise								Sequencer := None;						end;					end;				BtnItem: 					case The_Item of						B1: 							Frame_Count := Sequencer_Count;						B2: 							Frame_Count := 0;					end;			end;		until The_Type = BtnItem;		DisposDialog(The_Dialog);	end;(* Dialog for Stop Motion run-time options. *)	procedure Get_StopMotion_Options;		const			B1 = 1;                   (* Ok button item *)			B2 = 2;                   (* Cancel button item *)			SS = 4;                   (* Start Frame item *)			SE = 6;                   (* End Frame item *)			RX = 7;                   (* Exposures On radio item *)			RN = 8;                   (* Exposures Off radio item *)			RF = 9;                   (* Forward Run radio item *)			RR = 10;                  (* Reverse Run radio item *)			RM = 11;                  (* Manual Run  radio item *)			RA = 12;                  (* Automatic Run radio item *)		var			item: integer;			The_RadHdl: Handle;        (* radio button item handle *)			The_TextHdl: Handle;       (* text item handle *)			The_Text: Str255;          (* text string *)			Start_Run: Integer;        (* start run frame *)			End_Run: Integer;          (* end run frame *)			RHA: array[RX..RA] of Handle;      (* array of radio button handles *)	begin		The_Dialog := GetNewDialog(StopId, nil, Pointer(-1));		Start_Run := 0;		End_Run := Preset_Count;		The_Text := '0';		GetDItem(The_Dialog, SS, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		The_Text := IntToStr(Preset_Count);		GetDItem(The_Dialog, SE, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelItext(The_Dialog, SE, 0, Length(The_Text));		for item := RX to RA do			begin				GetDItem(The_Dialog, item, The_Type, The_RadHdl, The_ItemBox);				RHA[item] := The_RadHdl;			end;		if Exposured then			SetCtlValue(ControlHandle(RHA[RX]), 1)		else			SetCtlValue(ControlHandle(RHA[RN]), 1);		if not Reversed then			SetCtlValue(ControlHandle(RHA[RF]), 1)		else			SetCtlValue(ControlHandle(RHA[RR]), 1);		if SingleFramed then			SetCtlValue(ControlHandle(RHA[RM]), 1)		else			SetCtlValue(ControlHandle(RHA[RA]), 1);		DoDefaultButton(The_Dialog);		repeat			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			case The_Type of				TextItem: 					begin						GetIText(The_ItemHdl, The_Text);						case The_Item of							SS: 								Start_Run := StrToInt(The_Text);							SE: 								End_Run := StrToInt(The_Text);						end;					end;				RadItem: 					begin						The_RadHdl := The_ItemHdl;						SetCtlValue(ControlHandle(The_RadHdl), 1);						case The_Item of							RX: 								Exposured := True;							RN: 								Exposured := False;							RF: 								Reversed := False;							RR: 								Reversed := True;							RM: 								SingleFramed := True;							RA: 								SingleFramed := False;						end;						case The_Item of							RX: 								SetCtlValue(ControlHandle(RHA[RN]), 0);							RN: 								SetCtlValue(ControlHandle(RHA[RX]), 0);							RF: 								SetCtlValue(ControlHandle(RHA[RR]), 0);							RR: 								SetCtlValue(ControlHandle(RHA[RF]), 0);							RM: 								SetCtlValue(ControlHandle(RHA[RA]), 0);							RA: 								SetCtlValue(ControlHandle(RHA[RM]), 0);						end;					end;				BtnItem: 					case The_Item of						B1: 							Frame_Count := End_Run - Start_Run;						B2: 							Frame_Count := 0;					end;			end;		until The_Type = BtnItem;		DisposDialog(The_Dialog);	end;(********** Utility menu operations **********)(* Dialog for Axis Mapping. *)	procedure Get_Axis_Map_Options;		const			AI = 4;                   (* Axis ID item *)			AM = 6;                   (* Axis Motor item *)			AN = 8;                   (* Axis Name *)			AmapId2 = 2051;           (* nested dialog box Id *)			MaxCh = 30;               (* max string width *)		type			StringX = string[MaxCh]; (* pick list string type *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)			Init_Dialog: DialogPtr;    (* nested dialog box for selections *)			PS: array[1..Max_Axes] of StringX;    (* pick list string *)			Mouse_Pt: Point;                       (* mouse click location *)			Yes_Box: Rect;                         (* Okay button location *)			No_Box: Rect;                         (* Cancel button loaction *)			Mouse_Event: EventRecord;              (* mouse click event *)			I: integer;	begin		Init_Dialog := GetNewDialog(AmapId, nil, Pointer(-1));		SetPort(Init_Dialog);                   (* for local coordinates *)		GetDItem(Init_DIalog, Ok, The_Type, The_ItemHdl, Yes_Box);		GetDItem(Init_Dialog, Cancel, The_Type, The_ItemHdl, No_Box);		GetDItem(Init_Dialog, AI - 1, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, 'AXIS    ID     DESCRIPTION');		The_Text := '';{$IFC THINK_PASCAL}		for I := 1 to Max_Axes do			with AA[I].A do				PS[I] := Concat(Id, '       ', IntToStr(No), '       ', Name);		for I := 1 to Max_Axes do			begin				while Length(PS[I]) < MaxCh do					PS[I] := Concat(PS[I], ' ');				PS[I][MaxCh] := CR;				The_Text := Concat(The_Text, PS[I]);			end;{$ELSEC}		for I := 1 to Max_Axes do			with AA[I].A do				PS[I] := Id + '       ' + IntToStr(No) + '       ' + Name;		for I := 1 to Max_Axes do			begin				while Length(PS[I]) < MaxCh do					PS[I] := PS[I] + ' ';				PS[I][MaxCh] := CR;				The_Text := The_Text + PS[I];			end;{$ENDC}		GetDItem(Init_Dialog, AI, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelIText(Init_Dialog, AI, 0, Length(PS[1]));		ShowWindow(WindowPtr(Init_Dialog));		I := 1;		repeat			repeat				repeat				until GetNextEvent(mDownMask, Mouse_Event);			until Mouse_Event.What = MouseDown;			SelIText(Init_Dialog, AI, 0, 0);			ShowWindow(Init_Dialog);			GlobalToLocal(Mouse_Event.Where);        (* for local coordinates *)			Mouse_Pt := Mouse_Event.Where;			if PtInRect(Mouse_Pt, The_ItemBox) then				I := Round(0.5 + 8.0 * (Mouse_Pt.V - The_ItemBox.Top) / (The_ItemBox.Bottom - The_ItemBox.Top));			if I < 1 then				I := 1			else if I > Max_Axes then				I := Max_Axes;			SelIText(Init_Dialog, AI, (I - 1) * Length(PS[I]), I * Length(PS[I]));			ShowWindow(Init_Dialog);		until (PtInRect(Mouse_Pt, Yes_Box)) or (PtInRect(Mouse_Pt, No_Box));		if PtInRect(Mouse_Pt, Yes_Box) then			begin				The_Dialog := GetNewDialog(AmapId2, nil, Pointer(-1));				with AA[I] do					begin						The_Text := A.Id;						GetDItem(The_Dialog, AI, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						The_Text := IntToStr(A.No);						GetDItem(The_Dialog, AM, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						The_Text := A.Name;						GetDItem(The_Dialog, AN, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						SelItext(The_Dialog, AN, 0, Length(The_Text));					end;				DoDefaultButton(The_Dialog);				repeat					ModalDialog(nil, The_Item);					GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);					if The_Type = TextItem then						begin							GetIText(The_ItemHdl, The_Text);							with AA[I] do								case The_Item of									AI: 										A.Id := The_Text;									AM: 										A.No := StrToInt(The_Text);									AN: 										A.Name := The_Text;								end;						end;				until (The_Type = BtnItem);				DisposDialog(The_Dialog);			end;		DisposDialog(Init_Dialog);	end;(* Dialog for User Units. *)	procedure Get_User_Units_Options;		const			UX = 4;                   (* User Axis item *)			UU = 6;                   (* User Unit item *)			UK = 8;                   (* User K-scaler item *)			UD = 10;                  (* User 1/K-scaler item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)			QQ: string[2];            (* axis Id *)			Axis_Okay: Boolean;        (* axis Id okay *)			J: Integer;                (* temp axis index *)	begin		The_Dialog := GetNewDialog(UnitId, nil, Pointer(-1));		I := 1;		QQ := AA[I].A.Id;		Axis_Okay := True;		repeat			if Axis_Okay then				with AA[I] do					begin						The_Text := A.Id;						GetDItem(The_Dialog, UX, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						The_Text := K.Units;						GetDItem(The_Dialog, UU, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						SelItext(The_Dialog, UU, 0, Length(The_Text));						The_Text := RealToStr(K.Kscale, K.DP);						GetDItem(The_Dialog, UK, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						The_Text := RealToStr(1.0 / K.Kscale, K.DP);						GetDItem(The_Dialog, UD, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						Axis_Okay := False;					end;			DoDefaultButton(The_Dialog);			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					with AA[I] do						case The_Item of							UU: 								K.Units := The_Text;							UK: 								K.Kscale := StrToReal(The_Text);							UD: 								K.Kscale := 1.0 / StrToReal(The_Text);							UX: 								QQ := The_Text;						end;				end;			if (The_Type = BtnItem) and (The_Item = Ok) then				begin					Case_Axis(QQ, Axis_Okay, J);					if Axis_Okay then						I := J;				end;		until (The_Type = BtnItem) and (The_Item = Cancel);		DisposDialog(The_Dialog);	end;(* Dialog for Motor Speeds. *)	procedure Get_Motor_Profile_Options;		const			MX = 4;                   (* Motor item *)			ML = 6;                   (* Low Speed item *)			MH = 8;                   (* High Speed item *)			MR = 10;                  (* Ramp Count item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)			QQ: string[2];            (* axis Id *)			Axis_Okay: Boolean;        (* axis Id okay *)			J: Integer;                (* temp axis index *)	begin		The_Dialog := GetNewDialog(MspdId, nil, Pointer(-1));		I := 1;		QQ := AA[I].A.Id;		Axis_Okay := True;		repeat			if Axis_Okay then				with AA[I] do					begin						The_Text := A.Id;						GetDItem(The_Dialog, MX, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						The_Text := RealToStr(R.Min_LowSpd, 0);						GetDItem(The_Dialog, ML, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						SelItext(The_Dialog, ML, 0, Length(The_Text));						The_Text := RealToStr(R.Max_HighSpd, 0);						GetDItem(The_Dialog, MH, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						The_Text := RealToStr(R.Max_RampCnt, 0);						GetDItem(The_Dialog, MR, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						Axis_Okay := False;					end;			DoDefaultButton(The_Dialog);			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					with AA[I] do						case The_Item of							ML: 								R.Min_LowSpd := StrToReal(The_Text);							MH: 								R.Max_HighSpd := StrToReal(The_Text);							MR: 								R.Max_RampCnt := StrToReal(The_Text);							MX: 								QQ := The_Text;						end;				end;			if (The_Type = BtnItem) and (The_Item = Ok) then				begin					Case_Axis(QQ, Axis_Okay, J);					if Axis_Okay then						I := J;				end;		until (The_Type = BtnItem) and (The_Item = Cancel);		DisposDialog(The_Dialog);	end;(********** motion control routines **********)(* Initialize motor speed. *)	procedure Do_Init_Motor;	begin		DrawStr('Initialize Motor...');		Get_Init_Options;		if The_Item = Ok then			InitM(AA[Index].M);	end;(* Run motor. *)	procedure Do_Run_Motor;	begin		DrawStr('Run Motor...');		Get_Run_Options;		if The_Item = Ok then			with AA[Index] do				begin					PrepM(M);					WaitOver;					RunM(M);				end;	end;(* Kill both motors, running or not. *)	procedure Do_Kill_Motor;		var			I: integer;	begin		DrawStr('Kill Motor...');		for I := 1 to Max_Axes do			KillM(AA[I].M);		Drawln;	end;(* Get motor running status. *)	procedure Do_Status_Motor;	begin		DrawStr('Status for Motor...');		Get_Status_Update;	end;(* Get motor position. *)	procedure Do_Position_Motor;	begin		DrawStr('Position for Motor...');		Get_Position_Update;	end;(* Run motor into limit switch position. *)	procedure Do_Limit_Motor;	begin		DrawStr('Limit Switch Run Motor...');		Get_Limit_Options;		if The_Item = Ok then			HomeM(AA[Index].M);	end;(* Move motor by user units. *)	procedure Do_Move_Motor;	begin		DrawStr('Move Motor...');		Get_Move_Options;		if The_Item = OK then			RunM(AA[Index].M);	end;(* Goto motor position by user units. *)	procedure Do_Goto_Motor;	begin		DrawStr('Goto Motor Position...');		Get_Goto_Options;		if The_Item = OK then			RunM(AA[Index].M);	end;(* Jog motor using keyboard arrow keys. *)	procedure Do_Jog_Motor;	begin		DrawStr('Jog Motor...');		Drawln;		Put_Jog_Keys;	end;(* Zero motor stepping position. *)	procedure Do_Zero_Motor;	begin		DrawStr('Zero Motor Position...');		Get_Zero_Options;		if The_Item = OK then			ZeroM(AA[Index].M);	end;(********** Sequencer routines **********)(* Run camera motor. *)(* 1 camera frame = 400 half steps per revolution. *)	procedure Pre_Run_Camera (F: Integer);	begin{$IFC ANIMAL_THINGM}		THINGM_Camera;		THINGM_FrameCount(F);		WaitOver; (* for ThingM OK *){$ELSEC}		with AA[CX] do			begin				M.StepCnt := F * K.Kscale;				PrepM(M);				WaitOver;			end;{$ENDC}	end;	procedure Run_Camera (F: Integer);	begin{$IFC ANIMAL_THINGM}		THINGM_Camera;		THINGM_Run;		WaitOver; (* for ThingM OK *){$ELSEC}		with AA[CX] do			RunM(M);{$ENDC}	end;(* Run projector motor. *)(* 1 projector frame = 200 full steps per revolution. *)	procedure Pre_Run_Projector (F: Integer);	begin{$IFC ANIMAL_THINGM}		THINGM_Projector;		THINGM_FrameCount(F);		WaitOver; (* for ThingM OK *){$ELSEC}		with AA[PX] do			begin				M.StepCnt := F * K.Kscale;				PrepM(M);				WaitOver;			end;{$ENDC}	end;	procedure Run_Projector (F: Integer);	begin{$IFC ANIMAL_THINGM}		THINGM_Projector;		THINGM_Run;		WaitOver; (* for ThingM OK *){$ELSEC}		with AA[PX] do			RunM(M);{$ENDC}	end;(* Run Camera only. *)	procedure Do_Camera;		var			F: Integer;		var			C: Integer;			Single: Integer;			Ticker: LongInt;	begin		DrawStr('Camera...');		Get_Camera_Options;		DrawStr(IntToStr(Frame_Count));		Drawln;		if The_Item = Ok then			begin				Get_Frame_Counts;				if Frame_Count = 0 then					Single := 0				else					Single := Frame_Count div Abs(Frame_Count);				Pre_Run_Camera(Frame_Count);				Run_Camera(Frame_Count);				Ticker := TickCount;				for C := 1 to Abs(Frame_Count) do					begin						Camera_Total := Camera_Total + Single;						Put_Frame_Counts;						repeat						until TickCount >= Ticker + C * Round(60.0 * AA[CX].K.Kscale / (AA[CX].M.HighSpd / 100.0));						WaitOver; (* ThingM continuous run *)					end;				WaitOver;				Trash_Frame_Counts;			end;	end;(* Run Projector only. *)	procedure Do_Projector;		var			F: Integer;		var			P: Integer;			Single: Integer;	begin		DrawStr('Projector...');		Get_Projector_Options;		DrawStr(IntToStr(Frame_Count));		Drawln;		if The_Item = Ok then			begin				Get_Frame_Counts;				if Frame_Count = 0 then					Single := 0				else					Single := Frame_Count div Abs(Frame_Count);				Pre_Run_Projector(Single);				for P := 1 to Abs(Frame_Count) do					begin						if KeyPressed or Button then							Put_Frame_Counts;						if not (The_Item = Cancel) then							begin								Run_Projector(Single);								WaitOver;								Projector_Total := Projector_Total + Single;								Put_Frame_Counts;								WaitOver; (* ThingM OK prompt *)             				end;					end;				Trash_Frame_Counts;			end;	end;(* Run Sequencer between camera and projector. *)	procedure Do_Sequencer;		var			F: Integer;			C, P: Integer;			CSingle, PSingle: Integer;			Ticker: LongInt;	begin		DrawStr('Sequencer...');		Get_Sequencer_Options;		DrawStr(IntToStr(Frame_Count));		Drawln;		if The_Item = Ok then			begin				case Sequencer of					Alternate: 						begin							Get_Frame_Counts;							if Camera_Cycle = 0 then								CSingle := 0							else								CSingle := Camera_Cycle div Abs(Camera_Cycle);							if Projector_Cycle = 0 then								PSingle := 0							else								PSingle := Projector_Cycle div Abs(Projector_Cycle);							Pre_Run_Camera(Camera_Cycle);							Pre_Run_Projector(PSingle);							for F := 1 to Abs(Frame_Count) do								begin									if KeyPressed or Button then										Put_Frame_Counts;									if not (The_Item = Cancel) then										begin											Run_Camera(Camera_Cycle);											Ticker := TickCount;											for C := 1 to Abs(Camera_Cycle) do												begin													Camera_Total := Camera_Total + CSingle;													Put_Frame_Counts;													repeat													until TickCount >= Ticker + C * Round(60.0 * AA[CX].K.Kscale / (AA[CX].M.Highspd / 100.0));                									WaitOver; (* ThingM CR *)                 								end;											WaitOver;											for P := 1 to Abs(Projector_Cycle) do												begin													Run_Projector(PSingle);													WaitOver;													Projector_Total := Projector_Total + PSingle;													Put_Frame_Counts;													WaitOver; (* ThingM OK *)               									end;										end;								end;							Trash_Frame_Counts;						end;      (* Alternate Sequencer *)					StepCamera: 						begin							Get_Frame_Counts;							if Camera_Cycle = 0 then								CSingle := 0							else								CSingle := Camera_Cycle div Abs(Camera_Cycle);							Pre_Run_Camera(CSingle);							if Projector_Cycle = 0 then								PSingle := 0							else								PSingle := Projector_Cycle div Abs(Projector_Cycle);							Pre_Run_Projector(PSingle);							for F := 1 to Abs(Frame_Count) do								begin									if KeyPressed or Button then										Put_Frame_Counts;									if not (The_Item = Cancel) then										begin											for P := 1 to Abs(Projector_Cycle) do												begin													Run_Camera(CSingle);													WaitOver;													Camera_Total := Camera_Total + CSingle;													Put_Frame_Counts;													WaitOver;													Run_Projector(PSingle);													WaitOver;													Projector_Total := Projector_Total + PSingle;													Put_Frame_Counts;													WaitOver;												end;											for C := 1 to Abs(Camera_Cycle - 1) do												begin													Run_Camera(CSingle);													WaitOver;													Camera_Total := Camera_Total + CSingle;													Put_Frame_Counts;													WaitOver;												end;										end;								end;							Trash_Frame_Counts;						end;      (* StepCamera Sequencer *)					SkipProjector: 						begin							Get_Frame_Counts;							if Camera_Cycle = 0 then								CSingle := 0							else								CSingle := Camera_Cycle div Abs(Camera_Cycle);							Pre_Run_Camera(CSingle);							if Projector_Cycle = 0 then								PSingle := 0							else								PSingle := Projector_Cycle div Abs(Projector_Cycle);							Pre_Run_Projector(PSingle);							for F := 1 to Abs(Frame_Count) do								begin									if KeyPressed or Button then										Put_Frame_Counts;									if not (The_Item = Cancel) then										begin											for C := 1 to Abs(Camera_Cycle) do												begin													Run_Camera(CSingle);													WaitOver;													Camera_Total := Camera_Total + CSingle;													Put_Frame_Counts;													WaitOver;													Run_Projector(PSingle);													WaitOver;													Projector_Total := Projector_Total + PSingle;													Put_Frame_Counts;													WaitOver;												end;											for P := 1 to Abs(Projector_Cycle - 1) do												begin													Run_Projector(PSingle);													WaitOver;													Projector_Total := Projector_Total + PSingle;													Put_Frame_Counts;													WaitOver;												end;										end;								end;							Trash_Frame_Counts;						end;      (* SkipProjector Sequencer *)				end;         (* case Sequencer *)			end;         (* if Sequencer at all *)	end;(* Run Stop Motion sequence. *)	procedure Do_Stop_Motion;		var			F: Integer;			Increment: Real;			Position: Real;			Ch: Char;	begin		DrawStr('Run Stop Motion sequence...');		Drawln;		Get_StopMotion_Options;		if The_Item = Ok then			begin				Pre_Run_Camera(1);				Pre_Run_Projector(1);				Index := 2;				Position := AA[Index].Q[0];				Projector_Total := Round(Position);				Get_Frame_Counts;				GetDItem(The_Dialog, 5, The_Type, The_TextHdl, The_ItemBox);				SetIText(The_TextHdl, 'Step Count');				for F := 1 to Preset_Count do					begin						if KeyPressed or Button then							Put_Frame_Counts;						if not (The_Item = Cancel) then							begin								if Exposured then									begin										Run_Camera(1);										WaitOver;										Camera_Total := Camera_Total + 1;										Put_Frame_Counts;										WaitOver;									end;								with AA[Index] do									begin										Increment := Q[F] - Q[F - 1];										M.StepCnt := K.Kscale * Increment;										M.StepCnt := Abs(M.StepCnt);										if M.StepCnt < 8.0 then											M.StepCnt := 8.0;										DriveM(M);										WaitOver;										RunM(M);										WaitOver;										Position := Position + Increment;										{$IFC DEBUG_CONSOLE}										Writeln(F : 10, Increment : 10 : K.dp, Position : 10 : K.dp);										{$ENDC}										Projector_Total := Round(Position);										Put_Frame_Counts;										WaitOver;										if SingleFramed then											begin												repeat												until KeyPressed or Button;												if KeyPressed then													Ch := ReadKey;												if Button then													repeat														TpDelay(15);													until not Button;											end;									end;							end;					end;				Trash_Frame_Counts;			end;	end;(* Run Go Motion sequence. *)	procedure Do_Go_Motion;	begin		Do_Stop_Motion;	end;(* Run Continuous Motion sequence. *)	procedure Do_Continuous_Motion;	begin		SingleFramed := False;		Do_Stop_Motion;	end;(***** Utilities *****)(* Install Axis Map. *)	procedure Do_Axis_Map;		var			S: string;			I: integer;	begin		DrawStr('Axis Map...');		Drawln;		Drawln;		for I := 1 to Max_Axes do			with AA[I].A do				begin{$IFC THINK_PASCAL}					S := Concat(Id, ' ', IntToStr(No), ' ', Name);{$ELSEC}					S := Id + ' ' + IntToStr(No) + ' ' + Name;{$ENDC}					DrawStr(S);					Drawln;				end;		Get_Axis_Map_Options;	end;(* Install User Units. *)	procedure Do_User_Units;		var			S: Str255;			I: integer;	begin		DrawStr('User Units...');		Drawln;		Drawln;		for I := 1 to Max_Axes do			with AA[I].K do				begin{$IFC THINK_PASCAL}					S := Concat(AA[I].A.Id, ' ', RealToStr(Kscale, DP), ' ', IntToStr(DP), ' ', Units);{$ELSEC}					S := AA[I].A.Id + ' ';					S := S + RealToStr(Kscale, DP) + ' ' + IntToStr(DP) + ' ' + Units;{$ENDC}					DrawStr(S);					Drawln;				end;		Get_User_Units_Options;	end;(* Install Motor Speed Profiles. *)	procedure Do_Motor_Profiles;		var			S: Str255;			I: integer;	begin		DrawStr('Motor Speeds...');		Drawln;		Drawln;		for I := 1 to Max_Axes do			with AA[I].R do				begin{$IFC THINK_PASCAL}					S := Concat(AA[I].A.Id, ' ');					if AccelSt then						S := Concat(S, 'Accel / Decel  ')					else						S := Concat(S, 'Constant Speed ');					S := Concat(S, RealToStr(Max_Speed, 0), ' ', RealToStr(Min_LowSpd, 0), ' ', RealToStr(Max_HighSpd, 0), ' ', RealToStr(Max_RampCnt, 0));{$ELSEC}					S := AA[I].A.Id + ' ';					if AccelSt then						S := S + 'Accel / Decel  '					else						S := S + 'Constant Speed ';					S := S + RealToStr(Max_Speed, 0) + ' ' + RealToStr(Min_LowSpd, 0) + ' ' + RealToStr(Max_HighSpd, 0) + ' ' + RealToStr(Max_RampCnt, 0);{$ENDC}					DrawStr(S);					Drawln;				end;		Get_Motor_Profile_Options;	end;(********** Special menu operations for Point-Plotter **********)(* Test 2-point taper routines. *)	procedure Compute_Increments (var PX: Parameter_Table; var QX: Point_Table);		var			F: Integer;			A: Integer;			C: Integer;			D: Integer;			Frame_Count: Integer;			Accel_Count: Integer;			Const_Count: Integer;			Decel_Count: Integer;			Area_Accel: Real;			Area_Const: Real;			Area_Decel: Real;			Area_Total: Real;			Position: Real;			Increment: Real;	begin		with PX do			begin				IncrMax := (EndPoint - StartPoint) / (EndFrame - StartFrame);				if Taper then					begin						Frame_Count := EndFrame - StartFrame;						Accel_Count := Round(Accel / 100.0 * Frame_Count);						Decel_Count := Round(Decel / 100.0 * Frame_Count);						Const_Count := Frame_Count - (Accel_Count + Decel_Count);						Area_Accel := 0.0;						if Accel_Count > 0 then							for A := 1 to Accel_Count do								Area_Accel := Area_Accel + Sin(Pi / 2 * A / Accel_Count);						Area_Decel := 0.0;						if Decel_Count > 0 then							for D := Decel_Count downto 1 do								Area_Decel := Area_Decel + Sin(Pi / 2 * D / Decel_Count);						Area_Const := 1.0 * Const_Count;						Area_Total := Area_Accel + Area_Const + Area_Decel;						IncrMax := (EndPoint - StartPoint) / Area_Total;					end;				Position := StartPoint;				for F := 0 to Preset_Count do					begin						if F <= StartFrame then							Position := StartPoint						else if F >= EndFrame then							Position := EndPoint						else							begin								Increment := IncrMax;								if Taper then									begin										A := F - StartFrame;										D := EndFrame - F + 1;										if F < StartFrame + Accel_Count then											Increment := IncrMax * Sin(Pi / 2 * A / Accel_Count)										else if F > EndFrame - Decel_Count then											Increment := IncrMax * Sin(Pi / 2 * D / Decel_Count)										else											Increment := IncrMax;									end;								Position := Position + Increment;							end;						QX[F] := Position;					end;			end;	end;	procedure Do_Axis_Increments;		var			I: integer;	begin		DrawStr('Axis Positioning Cues...');		Index := 2;		with AA[Index] do			if not P.Spec then				begin					P.Spec := True;					if P.EndFrame < Preset_Count then						P.EndFrame := Preset_Count;				end;		Get_Axis_Increments(AA[Index].P);		Drawln;		if The_Item = Ok then			begin				SetCursor(CursList[WatchCursor]^^);				Compute_Increments(AA[Index].P, AA[Index].Q);				for I := 1 to Preset_Count do					begin					{$IFC DEBUG_CONSOLE}					Writeln(I : 10, AA[Index].Q[I] : 10 : 3);					{$ENDC}					end;{$IFC SYSTEM75_NEWLIBS}				SetCursor(qd.Arrow);{$ELSEC}				SetCursor(Arrow);{$ENDC}			end;	end;(*****)(* Graphics routines. *){$S PlotSeg}(* Cheap N Quick display of tapered array. *)	procedure Do_Point_Plotter;		const			X_SIZE = 470;			Y_SIZE = 270;		var			Xscale: Real;			Yscale: Real;			I: integer;	begin		DrawStr('Point Plotting...');		Drawln;		if Preset_Count > 1 then			begin				Index := 2;				Xscale := X_SIZE / Preset_Count;				Yscale := Y_SIZE / (AA[Index].Q[Preset_Count] - AA[Index].Q[1]);				MoveTo(Round(Xscale), Round(Yscale * AA[Index].Q[1]));				for I := 1 to Preset_Count do					LineTo(Round(Xscale * I), Round(Yscale * AA[Index].Q[I]));			end;	end;{$IFC ANIMAL_PLOT}(* Spline routines from Turbo Graphics Toolbox. *)(* Think Pascal version OK in IDE, but does not complete interpolation in APP. *)(* OA[x][1] values OK, but OA[x][2] values all "NAN(255)" *)(* B[x], C[x], D[x] return "NAN(255)" for effective indexes only, otherwise 0.0 *)(* tried the following: *)(* increased stack from 16k to 64k *)(* decreased MaxPlotGlb from 100 to 10 *)(* range checking on *)(* referencing B,C,D arrays explifcitly within SplineEval function *)(* moving B,C,D arrays to global data area *)(* upgrading Float from Real to Double *){$PUSH}{$R+}{$V+}	const		MaxPlotGlb = 10;    (* max points *)	type		Float = Double;		PlotArray = array[1..MaxPlotGlb] of array[1..2] of Float;	var		IA: PlotArray;		OA: PlotArray;(* Display Turbo Graphics Error Codes. *)	procedure Error (Code1, Code2: Integer);	begin		DrawStr('Error ');		DrawStr(IntToStr(Code1));		DrawStr(' , ');		DrawStr(IntToStr(Code2));		case Code2 of			4: 				DrawStr(': not enough points to interpolate');			7: 				DrawStr(': X coordinates out of interpolation range');		end;		Drawln;	end;	type		Vector = array[1..MaxPlotGlb] of Float;	var		B, C, D: Vector;(* Compute spline of input array into output array. *)	procedure Spline (var AA: PlotArray; N: integer; X1, Xm: Float; var BB: PlotArray; M: integer);		var			I, K: integer;			Dx, T: Float;		function SplineEval (T: Float; var I: integer): Float;			var				J, K: integer;				Dx: Float;				Dy: Float;		begin			if I >= N then				I := 1;			if (T < AA[I, 1]) or (T > AA[I + 1, 1]) then				begin					I := 1;					J := N + 1;					repeat						K := (I + J) div 2;						if T < AA[K, 1] then							J := K;						if T >= AA[K, 1] then							I := K;					until J <= (I + 1);				end;			Dx := T - AA[I, 1];{$IFC DEBUG_SPLINE}			Drawstr(Realtostr(Dx, 0));			Drawstr('  ');			Dy := AA[I, 2];			Drawstr(Realtostr(Dy, 0));			Drawstr('  ');			Dy := Dy + Dx * B[I];			Drawstr(Realtostr(Dy, 0));			Drawstr('  ');			Dy := Dy + Dx * Dx * C[I];			Drawstr(Realtostr(Dy, 0));			Drawstr('  ');			Dy := Dy + Dx * Dx * Dx * D[I];			Drawstr(Realtostr(Dy, 0));			Drawstr('  ');{$ELSEC}			Dy := AA[I, 2] + Dx * (B[I] + Dx * (C[I] + Dx * D[I]));{$ENDC}			SplineEval := Dy;		end; { SplineEval }	begin { Spline }		for I := 1 to MaxPlotGlb do			begin				B[I] := 0.0;				C[I] := 0.0;				D[I] := 0.0;			end;		if N >= 3 then			begin				D[1] := AA[2, 1] - AA[1, 1];				C[2] := (AA[2, 2] - AA[1, 2]) / D[1];				for I := 2 to N - 1 do					begin						D[I] := AA[I + 1, 1] - AA[I, 1];						B[I] := 2.0 * (D[I - 1] + D[I]);						C[I + 1] := (AA[I + 1, 2] - AA[I, 2]) / D[I];						C[I] := C[I + 1] - C[I];					end;				B[1] := -D[1];				B[N] := -D[N - 1];				C[1] := 0.0;				C[N] := 0.0;				if N > 3 then					begin						C[1] := C[3] / (AA[4, 1] - AA[2, 1]) - C[2] / (AA[3, 1] - AA[1, 1]);						C[N] := C[N - 1] / (AA[N, 1] - AA[N - 2, 1]) - C[N - 2] / (AA[N - 1, 1] - AA[N - 3, 1]);						C[1] := C[1] * Sqr(D[1]) / (AA[4, 1] - AA[1, 1]);						C[N] := -C[N] * Sqr(D[N - 1]) / (AA[N, 1] - AA[N - 3, 1]);					end;				for I := 2 to N do					begin						T := D[I - 1] / B[I - 1];						B[I] := B[I] - T * D[I - 1];						C[I] := C[I] - T * C[I - 1];					end;				C[N] := C[N] / B[N];				for I := N - 1 downto 1 do					C[I] := (C[I] - D[I] * C[I + 1]) / B[I];				B[N] := (AA[N, 2] - AA[N - 1, 2]) / D[N - 1] + D[N - 1] * (C[N - 1] + 2.0 * C[N]);				for I := 1 to N - 1 do					begin						B[I] := (AA[I + 1, 2] - AA[I, 2]) / D[I] - D[I] * (C[I + 1] + 2.0 * C[I]);						D[I] := (C[I + 1] - C[I]) / D[I];						C[I] := 3.0 * C[I];					end;				C[N] := 3.0 * C[N];				D[N] := D[N - 1];			end		else if N = 2 then			begin				B[1] := (AA[2, 2] - AA[1, 2]) / (AA[2, 1] - AA[1, 1]);				C[1] := 0.0;				D[1] := 0.0;				B[2] := B[1];				C[2] := 0.0;				D[2] := 0.0;			end;{$IFC DEBUG_SPLINE}		for I := 1 to MaxPlotGlb do			begin				Drawstr(inttostr(I));				Drawstr('  ');				Drawstr(realtostr(B[I], 0));				Drawstr('  ');				Drawstr(realtostr(C[I], 0));				Drawstr('  ');				Drawstr(realtostr(D[I], 0));				Drawln;			end;{$ENDC}		if (N >= 2) and (M >= 2) then			if (X1 >= AA[1, 1]) and (Xm <= AA[N, 1]) then				begin					Dx := (Xm - X1) / (M - 1);					K := 1;					for I := 1 to M do						begin							BB[I, 1] := X1 + (I - 1) * Dx;{$IFC DEBUG_SPLINE}							DrawStr(IntToStr(I));							DrawStr('   ');							DrawStr(RealToStr(BB[I, 1], 0));							DrawStr('   ');							BB[I, 2] := SplineEval(BB[I, 1], K);							DrawStr(RealToStr(BB[I, 2], 0));							Drawln;{$ELSEC}							BB[I, 2] := SplineEval(BB[I, 1], K);{$ENDC}						end;				end			else				Error(20, 7)		else			Error(20, 4);	end; { Spline }(* Interpolate points with display graphics. *)	procedure Do_Interpolation;		const			MaxPts = MaxPlotGlb;		var			Mouse_Pt: Point;			P: Integer;			S: Integer;	begin		DrawStr('Interpolation Graphics...');		Drawln;		DrawStr('use Mouse to plot points, then press Key to interpolate');		Drawln;		for P := 1 to MaxPlotGlb do			begin				IA[P, 1] := 0.0;				IA[P, 2] := 0.0;				OA[P, 1] := 0.0;				OA[P, 2] := 0.0;			end;		P := 0;		SetCursor(CursList[CrossCursor]^^);		repeat			repeat			until Button or KeyPressed;			if not KeyPressed then				begin					SetCursor(CursList[PlusCursor]^^);					for S := 1 to MaxInt do						;					repeat					until not WaitMouseUp; (* StillDown *)					GetMouse(Mouse_Pt);					P := P + 1;					IA[P, 1] := Mouse_Pt.H;					IA[P, 2] := Mouse_Pt.V;					SetCursor(CursList[CrossCursor]^^);					if P <= 1 then						MoveTo(Mouse_Pt.H, Mouse_Pt.V)					else						LineTo(Mouse_Pt.H, Mouse_Pt.V);				end;		until KeyPressed;		SetCursor(CursList[WatchCursor]^^);		Spline(IA, P, IA[1, 1], IA[P, 1], OA, MaxPts);		MoveTo(integer(Round(OA[1, 1])), integer(Round(OA[1, 2])));		for S := 2 to MaxPts do			LineTo(integer(Round(OA[S, 1])), integer(Round(OA[S, 2])));{$IFC SYSTEM75_NEWLIBS}		SetCursor(qd.Arrow);{$ELSEC}		SetCursor(Arrow);{$ENDC}{$IFC DEBUG_SPLINE}		for S := 1 to MaxPts do			begin				DrawStr(IntToStr(S));				DrawStr('   ');				DrawStr(RealToStr(OA[S, 1], 0));				DrawStr('   ');				DrawStr(RealToStr(OA[S, 2], 0));				Drawln;			end;{$ENDC}	end;{$POP}{$ENDC} 			(* ANIMAL_PLOT *)(*************************************************************)(* Brings up Standard Open-File Dialog Box and Opens a File. *)	procedure Do_Open_File;		var			The_FileName: Str255;       { file name by string               }			VolRefNum: Integer;      { volume refernce by number         }			FileRefNum: Integer;      { file reference number             }			FileErr: OSErr;        { Mac OS calling error              }			topLeft: Point;         { location for standard dialog box  }			FileFilter: SFTypeList;    { list of standard file types       }			Reply: SFReply;       { standard file package reply record}	begin		DrawStr('Open File...');		topLeft.h := 90;             { top left horiz point for Get File dialog }		topLeft.v := 80;             { top left vert    "    "   "    "    "    }		FileFilter[0] := 'TEXT';     { file filter for text files               } 		(* Standard File-Open dialog box *){$IFC CODEWARRIOR_PASCAL}		SFGetFile(topLeft, '', nil, +1, @FileFilter, nil, Reply);{$ELSEC}		SFGetFile(topLeft, '', nil, +1, FileFilter, nil, Reply);{$ENDC}		if Reply.Good then			begin				VolRefNum := Reply.vRefNum;				The_FileName := Reply.fName;				DrawStr(The_FileName);			end;	end;(*****){   *********   items in Apple Menu   *********** }(* DoAbout bring up 'About...' box using a dialog box *)	procedure DoAbout;		var			theItem: Integer;			AboutPtr: DialogPtr;			S1, S2, S3: StringHandle;	begin{$IFC SYSTEM75_NEWLIBS}		SetCursor(qd.Arrow);{$ELSEC}		SetCursor(Arrow);                    { set cursor                    }{$ENDC}		ShowCursor;                           { and turn it back on           }		S1 := GetString(Text1ID);             { get text from resource file   }		S2 := GetString(Text2ID);		S3 := GetString(Text3ID);		ParamText(S1^^, S2^^, S3^^, '');         { and set up as parameter text  }		AboutPtr := getNewDialog(AboutID, nil, Pointer(-1));    { get dialog box}		DoDefaultButton(AboutPtr);				{ draw bold outline around OK button }		ModalDialog(nil, theItem);             { put dialog box up; get result }		DisposDialog(AboutPtr);               { get rid of dialog box         }{$IFC SYSTEM75_NEWLIBS}		SetCursor(qd.Arrow);{$ELSEC}		SetCursor(Arrow);{$ENDC}	end; { of proc DoAbout }(* DoDeskAcc start up desk accessory from Apple menu *)	procedure DoDeskAcc (Item: Integer);		var			SavePort: GrafPtr;			RefNum: Integer;			DName: Str255;	begin		GetPort(SavePort);                    { save port before starting it  }		GetItem(MenuList[AM], Item, DName);     { get name of desk accessory    }		refNum := OpenDeskAcc(DName);         { and start that sucker up!     }		SetPort(SavePort);                    { restore grafport and continue }	end; { of proc DoDeskAcc }{   *********   event handling routines   *********** }(* ToggleFlag checks or de-checks item Indx in menu Mndx *)	procedure ToggleFlag (var Flag: Boolean; Mndx, Indx: Integer);		var			Ch: Char;	begin		Flag := not Flag;                     { toggle flag (for you)         }		if Flag then                               { if flag is True...            }			Ch := Chr(CheckMark)           {   then check item in menu     }		else			Ch := Chr(NoMark);             {   else clear any checkmark    }		SetItemMark(MenuList[Mndx], Indx, Ch)   { put char by item in menu      }	end; { of proc ToggleFlag }(* SetItemState if true, enables item Indx of menu Mndx; else disables *)	procedure SetItemState (Mndx, Indx: Integer; Flag: Boolean);	begin		if Flag then			EnableItem(MenuList[Mndx], Indx)		else			DisableItem(MenuList[Mndx], Indx)	end; { of proc SetItemState }(* UpdateMenu enable or disable items in I/O menu as needed *)	procedure UpdateMenu;	begin	end; { of proc UpdateMenu }(* HandleMenu decode MenuInfo and carry out command *)	procedure HandleMenu (MenuInfo: LongInt);		var			Menu: Integer;          { menu number that was selected     }			Item: Integer;          { item in menu that was selected    }			B: Boolean;          { dummy flag for SystemEdit call    }	begin		if MenuInfo <> 0 then			begin				ClearWindow(MainPtr);           { we're clearing the window         }				PenNormal;                      { set the pen back to normal        }				Menu := HiWord(MenuInfo);       { find which menu the command is in }				Item := LoWord(MenuInfo);       { get the command number            }				case Menu of                    { and carry it out                  }					ApplMenu: 						if Item = 1 then							DoAbout            { bring up "About..." window}						else							DoDeskAcc(Item);   { start desk accessory      }					FileMenu: 						case Item of							MFO: 								Do_Open_File;							MFQ: 								Finished := True;  { Quit command              }						end;					EditMenu: 						case Item of							MEU, MEX..MED: 								if not SystemEdit(Item - 1) then { pass to desk acc    } { do nothing }									;							MEF: 								Edit_Preset_Counts;							MEA: 								begin									Do_Axis_Increments;									Do_Point_Plotter;								end;							MET: 								Edit_Frame_Counts;						end;					RunnMenu: 						case Item of              { Run Menu                  }							MRC: 								Do_Camera;							MRP: 								Do_Projector;							MRS: 								Do_Sequencer;							MRM: 								Do_Stop_Motion;							MRG: 								Do_Go_Motion;							MRL: 								Do_Continuous_Motion;						end;					OverMenu: 						case Item of              { Overide menu              }							MOI: 								Do_Init_Motor;							MOR: 								Do_Run_Motor;							MOK: 								Do_Kill_Motor;							MOS: 								Do_Status_Motor;							MOP: 								Do_Position_Motor;							MOM: 								Do_Move_Motor;							MOG: 								Do_Goto_Motor;							MOJ: 								Do_Jog_Motor;							MOL: 								Do_Limit_Motor;							MOZ: 								Do_Zero_Motor;						end;					UtilMenu: 						case Item of              { Utilities menu            }							MUI: 								Do_Axis_Map;							MUM: 								Do_Motor_Profiles;							MUU: 								Do_User_Units;						end;					SpecMenu: 						case Item of              { Special menu              }{$IFC ANIMAL_PLOT}							MSP: 								Do_Point_Plotter;							MSI: 								Do_Interpolation;							MSC: 								;							MST: 								;{$ENDC}{$IFC ANIMAL_RGB}							MSD: 								Do_RGB_Direct;							MSP: 								begin									Edit_Preset_Counts;									Do_RGB_Program;								end;							MSR: 								Do_RGB_Run;							MSC: 								Do_RGB_Color_Table;{$ENDC}						end;				end;{case of Menu}				HiliteMenu(0);                          { reset menu bar            }				UpdateMenu;                             { make any changes needed   }			end	end; {of proc HandleMenu}(* HandleClick handle mouse click within window *)	procedure HandleClick (WPtr: WindowPtr; MLoc: Point);	begin		if WPtr = MainPtr then                         { if this is our window...  }			if WPtr <> FrontWindow then             { and it's not in front...  }				SelectWindow(WPtr)               { ...then make it active    }	end; { of proc HandleClick }(* HandleGoAway handle mouse click in go-away box *)	procedure HandleGoAway (WPtr: WindowPtr; MLoc: Point);		var			WPeek: WindowPeek;           { for looking at windows    }	begin		if WPtr = FrontWindow then			begin          { if it's the active window }				WPeek := WindowPeek(WPtr);              { peek at the window        }				if TrackGoAway(WPtr, MLoc) then					begin    {   and the box is clicked  }						if WPeek^.WindowKind = userKind then       {     if it's our window    }							Finished := True               {       then time to stop   }						else							CloseDeskAcc(WPeek^.WindowKind){       else close DeskAcc  }					end			end		else			SelectWindow(WPtr)                   { else make it active       }	end; { of proc HandleGoAway }(* HandleGrow handle mouse click in grow box *)	procedure HandleGrow (WPtr: WindowPtr; MLoc: Point);		type			GrowRec = record					case Integer of						0: (								Result: LongInt						);						1: (								Height, Width: Integer						)				end;		var			GrowInfo: GrowRec;	begin		if WPtr = MainPtr then			with GrowInfo do				begin { if it's our window    }					Result := GrowWindow(WPtr, MLoc, GrowArea);   {   get amt of growth   }					SizeWindow(WPtr, Width, Height, True);         {   resize window       }					InvalRect(WPtr^.portRect)                   {   set up for update   }				end	end; { of proc HandleGrow }(* DoMouseDown identify where mouse was clicked and handle it *)	procedure DoMouseDown (theEvent: EventRecord);		var			Location: Integer;			theWindow: WindowPtr;			MLoc: Point;			WLoc: Integer;	begin		MLoc := theEvent.Where;              { get mouse position            }		WLoc := FindWindow(MLoc, theWindow);   { get window, loc in window     }		case WLoc of                          { handle window locations       }			InMenuBar: 				HandleMenu(MenuSelect(MLoc));     { in the menu       }			InContent: 				HandleClick(theWindow, MLoc);      { inside the window }			InGoAway: 				HandleGoAway(theWindow, MLoc);     { in the go away box}			InGrow: 				HandleGrow(theWindow, MLoc);       { in the grow box   }			InDrag: 				DragWindow(theWindow, MLoc, DragArea); { in the drag bar}			InSysWindow: 				SystemClick(theEvent, theWindow)   { in a DA window    }		end	end; { of proc DoMouseDown }(* DoKeypress handles keypress (keyDown, autoKey) event *)	procedure DoKeypress (theEvent: EventRecord);		var			KeyCh: Char;	begin{$IFC THINK_PASCAL}		if (BitAnd(theEvent.modifiers, cmdKey) <> 0) then			begin { menu key command }				KeyCh := Chr(BitAnd(theEvent.Message, charCodeMask)); { decode character }				HandleMenu(MenuKey(KeyCh))                       { get menu and item}			end{$ELSEC}			if ((theEvent.modifiers and cmdKey) <> 0) then				begin { menu key command }					KeyCh := Chr(theEvent.Message and charCodeMask); { decode character }					HandleMenu(MenuKey(KeyCh))                       { get menu and item}				end{$ENDC}			else				SysBeep(1)                                     { do *something*  }	end; { of proc DoKeypress }(* DoUpdate handles window update event *)	procedure DoUpdate (theEvent: EventRecord);		var			SavePort, theWindow: WindowPtr;	begin		theWindow := WindowPtr(theEvent.Message);     { find which window     }		if theWindow = MainPtr then			begin             { only update ours      }				SetCursor(CursList[watchCursor]^^);         { set cursor to watch   }				GetPort(SavePort);                          { save current grafport }				SetPort(theWindow);                         { set as current port   }				BeginUpdate(theWindow);                     { signal start of update}  { and here's the update stuff! }				ClearWindow(theWindow);                     { do update stuff       }  { now, back to our program...}				EndUpdate(theWindow);                       { signal end of update  }				SetPort(SavePort);                          { restore grafport      }{$IFC SYSTEM75_NEWLIBS}				SetCursor(qd.Arrow);{$ELSEC}				SetCursor(Arrow);                           { restore cursor        }{$ENDC}			end	end; { of proc DoUpdate }(* DoActivate handles window activation event *)(* Note: Menu specific updates here. *)	procedure DoActivate (theEvent: EventRecord);		var			I: Integer;			AFlag: Boolean;			theWindow: WindowPtr;	begin		with theEvent do			begin				theWindow := WindowPtr(Message);            { get the window        }				AFlag := Odd(Modifiers);                    { get activate/deactive }				if AFlag then					begin                         { if it's activated...  }						SetPort(theWindow);                       {   make it the port    }						FrontWindow := theWindow;                 {   know it's in front  }						DrawGrowIcon(theWindow);                  {   set size box        }					end				else					begin						SetPort(ScreenPort);                      { else reassign port    }						if theWindow = FrontWindow then                { if it's in front      }							FrontWindow := nil                 { ...then forget that   }					end;				if theWindow = MainPtr then					begin           { if it's our window    }						SetItemState(FM, 1, not AFlag);             {   update File cmds    }						for I := MFN to MFC do							SetItemState(FM, I, AFlag);						SetItemState(FM, MFQ, AFlag);               {   update Quit command }						for I := MEU to MED do                    {   update Edit cmds    }							SetItemState(EM, I, not AFlag);						for I := RM to SM do                      {   update other menus  }							SetItemState(I, 0, AFlag);						DrawMenuBar                               {   update menu bar     }					end			end	end; { of proc DoActivate }(* Initialize everything for the program *)(* Note: Program specific stuff in separate procedure (above). *)	procedure Initialize;		var			Indx: Integer;			Result: Real;	begin  { initialize all the different managers                               }{$IFC SYSTEM75_NEWLIBS}		InitGraf(@qd.thePort);            { create a grafport for the screen  }{$ELSEC}		InitGraf(@thePort);               { create a grafport for the screen  }{$ENDC}		InitFonts;                        { start up the font manager         }		InitWindows;                      { start up the window manager       }		InitMenus;                        { start up the menu manager         }		TEInit;                           { start up the text manager for DAs }		InitDialogs(nil);                 { start up the dialog manager       }		FlushEvents(everyEvent, 0);        { clear events from previous state  }  { get four standard system cursors only                               }		for Indx := iBeamCursor to watchCursor do			begin				CursList[Indx] := GetCursor(Indx); { read in from system resource     }				HLock(Handle(CursList[Indx]))    { lock the handle down             }			end;		SetCursor(CursList[watchCursor]^^);{ bring up watch cursor            }  { set up menus }		MenuList[AM] := GetMenu(ApplMenu);{ read menus in from resource fork  }		MenuList[FM] := GetMenu(FileMenu);		MenuList[EM] := GetMenu(EditMenu);		MenuList[RM] := GetMenu(RunnMenu);		MenuList[OM] := GetMenu(OverMenu);		MenuList[UM] := GetMenu(UtilMenu);		MenuList[SM] := GetMenu(SpecMenu);		AddResMenu(MenuList[AM], 'DRVR');  { pull in all desk accessories      }		for Indx := 1 to MenuCnt do       { place menus in menu bar           }			InsertMenu(MenuList[Indx], 0);		DrawMenuBar;                      { draw updated menu bar to screen   }  { set up window stuff }		GetWMgrPort(ScreenPort);          { get grafport for all windows      }		SetPort(ScreenPort);              { and keep hand just in case        }		MainPtr := GetNewWindow(MainID, @MainRec, Pointer(-1));    { get window }		SetPort(MainPtr);                 { set window to current graf port   }		SelectWindow(MainPtr);            { and make window active            }		FrontWindow := MainPtr;           { remember that it's in front       }		DrawGrowIcon(MainPtr);            { draw the grow box in the corner   }		MainPeek := WindowPeek(MainPtr);  { get pointer to window record      }		MainPeek^.windowKind := UserKind; { set window type = user kind (ID=8)}{$IFC SYSTEM75_NEWLIBS}		ScreenArea := qd.screenBits.Bounds;  { get size of screen (don't assume) }{$ELSEC}		ScreenArea := screenBits.Bounds;  { get size of screen (don't assume) }{$ENDC}		with ScreenArea do			begin				SetRect(DragArea, 5, 25, Right - 5, Bottom - 10);   { set drag region       }				SetRect(GrowArea, 50, 20, Right - 5, Bottom - 10)   { set grow region       }			end;		TextFont(Monaco);                { select even-spaced font           }		TextSize(9);  { program specifics }  		(* init SIO unit to open serial interface drivers *)  		SIO_Init;		(* init GLOBAL vars unit *)		GLOBAL_Init;  		(* init all Animal variables *)		Init_Program_Stuff;               { init all program-specific stuff   }		UpdateMenu;                       { update menu as needed             }		Finished := False                 { set program terminator to false   }	end; { of proc Initialize }(* CleanUp to do whatever's needed before returning to Finder *)	procedure CleanUp;	begin		(* exit SIO unit to close serial interface drivers *)		SIO_Exit;		DisposeWindow(MainPtr)            { get rid of the main window        }	end; { of proc CleanUp }(* CursorAdjust change cursors depending upon location *)	procedure CursorAdjust;		var			MousePt: Point;	begin		if MainPtr = FrontWindow then			with MainPeek^ do				begin					GetMouse(MousePt);                          {  find where mouse is  }					if PtInRect(MousePt, port.portRect) then     {  if over window then  }						if Button then                                 {   if button down...   }							SetCursor(CursList[plusCursor]^^)  {    then make a plus   }						else							SetCursor(CursList[crossCursor]^^){    else make a cross  }					else{$IFC SYSTEM75_NEWLIBS}						SetCursor(qd.Arrow);{$ELSEC}						SetCursor(Arrow);                    {   else make an arrow  }{$ENDC}				end	end; { of proc CursorAdjust }(* HandleEvent decodes event and handles it *)	procedure HandleEvent (theEvent: EventRecord);	begin		case theEvent.What of			mouseDown: 				DoMouseDown(theEvent);      { mouse button pushed   }			keyDown: 				DoKeyPress(theEvent);       { key pressed down      }			autoKey: 				DoKeyPress(theEvent);       { key held down         }			updateEvt: 				DoUpdate(theEvent);         { window need updating  }			activateEvt: 				DoActivate(theEvent)        { window made act/inact }		end	end; { of proc HandleEvent }Begin { main body of program }   Initialize;                              { set everything up         }   repeat                                   { keep doing the following  }                   SystemTask;                            { update desk accessories   }     CursorAdjust;                          { update which cursor       }     if GetNextEvent(everyEvent,theEvent)   {   if there's an event...  }       then HandleEvent(theEvent);          {     ...then handle it     }     GetSpecialEvent;                       {   get special event too...}   until Finished;                          { until user is done        }   Cleanup;                                 { clean everything up       }End. { of program }