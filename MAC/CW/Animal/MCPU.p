(* MCPU null communications interface. *)(* Originally called MCPUNULL.PAS. *){$SETC MCPU_NULL = 0}				(* for null communications testing *)(* Adapted for CodeWarrior Pascal. *){$SETC CODEWARRIOR_PASCAL = 1}{$IFC CODEWARRIOR_PASCAL}Unit MCPU;{$ELSEC}(* Mac Turbo Pascal Unit declaration *)Unit MCPU(102);{$U-}{$ENDC}InterfaceUses{$IFC CODEWARRIOR_PASCAL}	TurboCrt,						(* Turbo Pascal style console extensions *)	TurboStr,						(* Turbo Pascal style string conversions *)	SIO,							(* serial interface *)	TIMEX;							(* timing routines *){$ELSEC}(* Mac Turbo Pascal Library Units *)     PasInOut,    PasConsole;{$ENDC}Const	LF = $0A;						(* Line Feed character *)	CR = $0D;						(* Carriage return character *)	BS = $08;						(* Backspace character *)	ESC = $1B;						(* Escape character *)Const    FWD = True;    REV = False;Type        Motor_Table = Record    MotorNo : Integer;              (* motor number *)    StepCnt : Real;                 (* step count *)    Dir     : Boolean;              (* step direction *)    AccelSt : Boolean;              (* acceleration status *)    Speed   : Integer;              (* constant speed *)    LowSpd  : Integer;              (* low speed *)    HighSpd : Integer;              (* high speed *)    RampCnt : Integer;              (* ramp count *)    RampK   : Integer;              (* ramp constant *)    Stat    : Char;                 (* axis status *)    Count   : Real;                 (* axis position *)    Error   : Boolean;              (* error status *)    end;(* MCPU routines inherited from new PC version of Animal for CompuMotor controller: *)    Procedure OutCmd (C : char);Procedure OutCmdStr (S : string);Procedure OutStr (Var S : string);Procedure InStr (Var S : string);Procedure InStrX (Var S : string; N : integer);Procedure WaitOver;(* MCPU routines inherited from old PC version of Animal for STD-bus motion controller: *)(* {$I MCPUCOMM.LIB} *)(* PROCEDURE OUTCMD (CH : CHAR); *)PROCEDURE TIMEOUT_MCPU (VAR STATUS : BOOLEAN);PROCEDURE RESET_MCPU;PROCEDURE INIT_MCPU;PROCEDURE READYMCPU;PROCEDURE SYNC_MCPU;PROCEDURE RESYNC_MCPU;PROCEDURE IDLE_MCPU;PROCEDURE NULL_MCPU;PROCEDURE OVERHEAR;PROCEDURE PREPM (VAR M : MOTOR_TABLE);PROCEDURE INTBYTE (VAR INTVAL : INTEGER; VAR BYTE_L, BYTE_H : CHAR);PROCEDURE BYTEINT (VAR BYTE_L, BYTE_H : CHAR; VAR INTVAL : INTEGER);PROCEDURE REALBYTE (VAR REALVAL : REAL; VAR BYTE_L, BYTE_H, BYTE_X : CHAR);PROCEDURE BYTEREAL (VAR BYTE_L, BYTE_H, BYTE_X : CHAR; VAR REALVAL : REAL);(* PROCEDURE OUTSTR (VAR S : STRING); *)PROCEDURE INTSTR (VAR INTVAL : INTEGER; VAR BYTESTR : STRING);PROCEDURE REALSTR (VAR REALVAL : REAL; VAR BYTESTR : STRING);PROCEDURE STRINT (VAR BYTESTR : STRING; VAR INTVAL : INTEGER);PROCEDURE STREAL (VAR BYTESTR : STRING; VAR REALVAL : REAL);(* {$I MCPUSTAT.EXT} *)FUNCTION DECODE_STATUS (VAR M : MOTOR_TABLE) : STRING;FUNCTION DECODE_QUICK (VAR M : MOTOR_TABLE) : STRING;FUNCTION DECODE_MOTION (VAR M : MOTOR_TABLE) : BOOLEAN;(* {$I MCPUSTAT.EXT} *)(* PROCEDURE WAITOVER; *)(* {$I MCPUX.LIB} *)PROCEDURE DRIVEX (VAR M : MOTOR_TABLE);PROCEDURE INITX (VAR M : MOTOR_TABLE);PROCEDURE RUNX (VAR M : MOTOR_TABLE);PROCEDURE KILLX (VAR M : MOTOR_TABLE);PROCEDURE ZEROX (VAR M : MOTOR_TABLE);PROCEDURE GETSTAT (VAR M : MOTOR_TABLE);PROCEDURE GETCOUNT_Software (VAR M : MOTOR_TABLE);PROCEDURE GETCOUNT_Hardware (VAR M : MOTOR_TABLE);PROCEDURE GETCOUNT (VAR M : MOTOR_TABLE);PROCEDURE GETX (VAR M : MOTOR_TABLE);PROCEDURE STATX (VAR M : MOTOR_TABLE);(* {$I MCPUM.LIB} *)PROCEDURE DRIVEM (VAR M : MOTOR_TABLE);PROCEDURE INITM (VAR M : MOTOR_TABLE);PROCEDURE RUNM (VAR M : MOTOR_TABLE);PROCEDURE KILLM (VAR M : MOTOR_TABLE);PROCEDURE ZEROM (VAR M : MOTOR_TABLE);PROCEDURE PULSEM (VAR M : MOTOR_TABLE);PROCEDURE HOMEM (VAR M : MOTOR_TABLE);PROCEDURE NOLIMITM (VAR M : MOTOR_TABLE);PROCEDURE VECTORM (VAR M : MOTOR_TABLE);PROCEDURE WHEREM (VAR M : MOTOR_TABLE);Implementation{$IFC NOT MCPU_NULL}(* MCPU routines for any string-based devices, like CompuMotor or ThingM. *)(* Output a command byte. (pass by value) *)Procedure OutCmd (C: char);Begin   OutSio (C);End;(* Output a command string. (pass by value) *)Procedure OutCmdStr (S : string);var i : integer;	c : char;Begin   for i := 1 to Length(S) do       begin       c := char(S[i]);       OutSio (c);       end;End;(* Output a command string. (pass by reference) *)Procedure OutStr (Var S : string);var i : integer;	c : char;Begin   for i := 1 to Length(S) do       begin       c := char(S[i]);       OutSio (c);       end;End;(* Input a response string, with terminator character. *)Procedure InStr (Var S : string);const TIMEOUT_DELAY = 100;              (* for 1 sec *)var i : integer;    ch : char;    status : boolean;    time, timeout : longint;Begin   S := '';   i := 1;   timeout := ThisTime + TIMEOUT_DELAY;   repeat      InSioSt(status);      if (status)         then begin         InSio(ch);         S[i] := ch;         S[0] := char(i);         Inc(i);         end;      time := ThisTime;   until (ch = char(CR)) OR (time >= timeout);End;(* Input a response string, in series of so many characters. *)Procedure InStrX (Var S : string; N : integer);const TIMEOUT_DELAY = 100;              (* for 1 sec *)var i : integer;    ch : char;    status : boolean;    time, timeout : longint;Begin   S := '';   i := 1;   timeout := ThisTime + TIMEOUT_DELAY;   repeat      InSioSt(status);      if (status)         then begin         InSio(ch);         S[i] := ch;         S[0] := char (i);         Inc(i);         end;      time := ThisTime;   until (i > N) OR (time >= timeout);End;(* Wait until current external command is over. *)(* Allows for breakout via key press or mouse click. *)Procedure WaitOver;const TIMEOUT_DELAY = 100;              (* for 1 sec *)var ch : char;    received, breakout : boolean;    time, timeout : longint;Begin	timeout := ThisTime + TIMEOUT_DELAY;	ch := char(0);	breakout := FALSE;	repeat      InSioSt(received);      if (received)         then begin          InSio(ch);         if (ch = char(CR))         	then breakout := TRUE;         end;      if (KeyPressed)      	 then breakout := TRUE;      if (TpMousePressed)      	 then breakout := TRUE;      time := ThisTime;   until (ch = char(CR)) OR (breakout) OR (time >= timeout);End;{$ELSEC}Procedure OutCmdStr (S : string);BeginEnd;Procedure InStr (Var S : string);Begin	S := '';End;Procedure InStrX (Var S : string; N : integer);Begin	S := '';End;{$ENDC}		(* MCPU_NULL *)(* MCPU command set routines for STD-bus MCPU. *)(* OUTPUT COMMAND outputs an ASCII character command to the MCPU. *)(* Note: OUTCMD passes by value, whereas OUTSIO passes by reference. *){$IFC MCPU_NULL}PROCEDURE OUTCMD { (CH : CHAR) };BEGINEND;{$ENDC}(* TIME-OUT MCPU times out the MCPU's response to the serial input port. *)PROCEDURE TIMEOUT_MCPU { (VAR STATUS : BOOLEAN) };BEGINEND;(* RESET MCPU resets the MCPU with null commands via the serial port. *)PROCEDURE RESET_MCPU;BEGINEND;(* INITIALIZE MCPU finds out if the MCPU is ready for communications(* with the host desktop computer. *)PROCEDURE INIT_MCPU;BEGINEND;(* READY MCPU loops until the MCPU is ready for command input. *)PROCEDURE READYMCPU;BEGINEND;(* SYNC MCPU synchronizes MCPU communications to be ready for a command. *)PROCEDURE SYNC_MCPU;BEGINEND;(* RE-SYNC MCPU re-syncronizes MCPU communications for an existing command. *)PROCEDURE RESYNC_MCPU;BEGINEND;(* IDLE MCPU syncronizes MCPU communications into idle. *)PROCEDURE IDLE_MCPU;BEGINEND;(* NULL MCPU nullifies an existing MCPU command sequence. *)PROCEDURE NULL_MCPU;BEGINEND;(* OVERHEAR commands the MCPU to not respond again until all axes are over. *)PROCEDURE OVERHEAR;BEGINEND;(* PREPM prepares the step count and direction for an MCPU motor. *)PROCEDURE PREPM { (VAR M : MOTOR_TABLE) };BEGIN   IF M.STEPCNT < 0      THEN M.DIR := REV      ELSE M.DIR := FWD;   M.STEPCNT := ABS (M.STEPCNT);END;(* INTBYTE converts a 16-bit Pascal integer into its corresponding(* two 8-bit bytes for output to the serial interface. *)PROCEDURE INTBYTE { (VAR INTVAL : INTEGER; VAR BYTE_L, BYTE_H : CHAR) };BEGINEND;(* BYTEINT converts two 8-bit bytes back into a 16-bit Pascal integer(* for input from the serial interface. *)PROCEDURE BYTEINT { (VAR BYTE_L, BYTE_H : CHAR; VAR INTVAL : INTEGER) };BEGINEND;(* REALBYTE converts a 24-bit Pascal real into its corresponding(* three 8-bit bytes for output to the serial interface. *)PROCEDURE REALBYTE { (VAR REALVAL : REAL; VAR BYTE_L, BYTE_H, BYTE_X : CHAR) };BEGINEND;(* BYTEREAL converts three 8-bit bytes back into a 24-bit Pascal real(* for input from the serial interface. *)PROCEDURE BYTEREAL { (VAR BYTE_L, BYTE_H, BYTE_X : CHAR; VAR REALVAL : REAL) };BEGINEND;(* OUTSTR outputs a string of characters to the serial interface. *){$IFC MCPU_NULL}PROCEDURE OUTSTR { (VAR S : STRING) };BeginEnd;{$ENDC}(* INTSTR converts a Pascal integer into a numerical string. *)PROCEDURE INTSTR { (VAR INTVAL : INTEGER; VAR BYTESTR : STRING) };BeginEnd;(* REALSTR converts a Pascal real into a numerial string. *)PROCEDURE REALSTR { (VAR REALVAL : REAL; VAR BYTESTR : STRING) };BeginEnd;(* STRINT converts a number string into a Pascal integer. *)PROCEDURE STRINT { (VAR BYTESTR : STRING; VAR INTVAL : INTEGER) };BeginEnd;(* STREAL converts a number string into a Pascal real. *)PROCEDURE STREAL { (VAR BYTESTR : STRING; VAR REALVAL : REAL) };BeginEnd;(* DECODE STATUS translates an MCPU axis status byte into a message string. *)FUNCTION DECODE_STATUS { (VAR M : MOTOR_TABLE) : STRING } ;BEGIN   Decode_Status := 'Ready (Null)';END;(* DECODE QUICK translates an MCPU axis status byte into a quick message. *)FUNCTION DECODE_QUICK { (VAR M : MOTOR_TABLE) : STRING } ;BEGIN   Decode_Quick := 'Ready';END;(* DECODE MOTION decodes an MCPU axis status byte for motion. *)(* MCPU command set for ThingM. *)FUNCTION DECODE_MOTION { (VAR M : MOTOR_TABLE) : BOOLEAN } ;BEGIN   Decode_Motion := False;END;(* Wait until all axes are over. *){$IFC MCPU_NULL}Procedure WaitOver;BeginEnd;{$ENDC}(* INITX pre-initializes an MCPU motor for either constant speed(* or ramped acceleration/deceleration operation. *)(* For use in nested MCPU 'Initialize' command block sequences. *)PROCEDURE INITX { (VAR M : MOTOR_TABLE) };BEGINEND;(* RUNX post-runs a pre-initialized MCPU motor with the minimum stepping(* information for synchronously activated motor axes. *)(* For use in nested MCPU 'Drive' command block sequences. *)PROCEDURE RUNX { (VAR M : MOTOR_TABLE) };BEGIN   If M.Dir = REV      Then M.Count := M.Count - M.StepCnt      Else M.Count := M.Count + M.StepCnt;END;(* DRIVEX drives an MCPU motor according to a step count, direction, and(* overiding constant or ramping speed, for immediate operation. *)(* For use in nested 'Drive' MCPU command block sequences. *)PROCEDURE DRIVEX { (VAR M : MOTOR_TABLE) };BEGIN   RunX (M);END;(* 'KILL MOTOR' stops the specified motor in mid flight. *)(* For use in nested MCPU 'Kill' command block sequences. *)PROCEDURE KILLX { (VAR M : MOTOR_TABLE) };BEGINEND;(* 'ZERO MOTOR' zeroes out an MCPU axis step position. *)(* For use in nested MCPU 'Zero' command block sequences. *)PROCEDURE ZEROX { (VAR M : MOTOR_TABLE) };BEGIN   M.Count := 0;END;(* GETX gets the status and position data from the MCPU, ready or not. *)(* For use in nested MCPU 'GetCount/GetStatus' command block sequences. *)PROCEDURE GETX { (VAR M : MOTOR_TABLE) };BEGINEND;(* 'STATUS MOTOR' gets the current status and step count of an MCPU axis. *)(* For use in nested MCPU 'Status' command block sequences. *)PROCEDURE STATX { (VAR M : MOTOR_TABLE) };BEGINEND;(* 'DRIVE_MOTOR' drives the step count, step rate, and direction(* for a specified MCPU motor. *)PROCEDURE DRIVEM { (VAR M : MOTOR_TABLE)} ;BEGIN   DRIVEX (M);                (* Drive motor *)END;(* 'INITIALIZE_MOTOR' initializes the specified motor for(* either constant speed or ramping speed operation. *)(* Subsequent 'RUN_MOTOR' sequences would run the motor(* at this particular set of speed characteristics. *)PROCEDURE INITM { (VAR M : MOTOR_TABLE) };BEGIN   INITX (M);                (* Init motor speed *)END;(* 'RUN_MOTOR' runs the step count and direction only for an MCPU motor. *)PROCEDURE RUNM { (VAR M : MOTOR_TABLE) };BEGIN   RUNX (M);                 (* Drive motor *)END;(* 'KILL_MOTOR' stops an MCPU motor in mid flight. *)PROCEDURE KILLM { (VAR M : MOTOR_TABLE) };BEGIN   KILLX (M);				(* Kill motor *)END;(* 'ZERO_MOTOR' zeroes out the cummulative step count for an MCPU axis. *)PROCEDURE ZEROM { (VAR M : MOTOR_TABLE) };BEGIN   ZEROX (M);				(* Zero motor count *)END;(* 'PULSE_MOTOR' pulses the specified motor 1 single step. *)PROCEDURE PULSEM { (VAR M : MOTOR_TABLE) };BEGINEND;(* HOME_MOTOR homes the specified motor into its limit-switch position. *)(* Homing occurs at constant speed according to pre-loaded MCPU speeds. *)PROCEDURE HOMEM { (VAR M : MOTOR_TABLE) };BEGINEND;(* NO LIMIT turns off the axis' switch mask for un-interrupted operation.*)PROCEDURE NOLIMITM { (VAR M : MOTOR_TABLE) };BEGINEND;(* GET_COUNT gets the current step count of an axis from the MCPU. *)PROCEDURE GETCOUNT { (VAR M : MOTOR_TABLE) };BEGINEND;(* GET_STAT gets the current motion status of an MCPU axis. *)PROCEDURE GETSTAT { (VAR M : MOTOR_TABLE) };BEGINEND;(* VECTORM changes a running MCPU motor's vector speed in real-time. *)PROCEDURE VECTORM { (VAR M : MOTOR_TABLE) };BEGINEND;(* WHEREM samples a running MCPU motor's step count in real-time. *)PROCEDURE WHEREM { (VAR M : MOTOR_TABLE) };BEGINEND;(* GETCOUNT_Software gets the cummulative M.Count logged in software(* for dumb motion control hardware, like CompuMotor 1200. *)PROCEDURE GETCOUNT_Software { (VAR M : MOTOR_TABLE) };BeginEnd;(* GETCOUNT_Hardware gets the cummulative M.Count logged within(* smart motion control hardware, like CompuMotor 2100 and PC23, or STD-bus MCPU. *)PROCEDURE GETCOUNT_Hardware { (VAR M : MOTOR_TABLE) };BeginEnd;End.