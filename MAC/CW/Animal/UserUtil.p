(********** Utility menu operations **********){$I SWITCHES.p}Unit UtilMenu;Interface	uses		Types, 		QuickDraw,		QuickDrawText,        Windows, 		Controls,        Dialogs,        Events,        TurboCrt,			(* Turbo Pascal style console extensions *)        TurboStr,			(* Turbo Pascal style string extensions *)        GLOBAL,				(* global vars *)        RezId,				(* resource file IDs *)        MCPU,				(* MCPU operations *)        USERIO;				(* user interface routines *)	procedure Get_Axis_Map_Options;	procedure Get_User_Units_Options;	procedure Get_Motor_Profile_Options;	procedure Do_Axis_Map;	procedure Do_User_Units;	procedure Do_Motor_Profiles;Implementation(* Dialog for Axis Mapping. *)	procedure Get_Axis_Map_Options;		const			AI = 4;                   (* Axis ID item *)			AM = 6;                   (* Axis Motor item *)			AN = 8;                   (* Axis Name *)			AmapId2 = 2051;           (* nested dialog box Id *)			MaxCh = 30;               (* max string width *)		type			StringX = string[MaxCh]; (* pick list string type *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)			Init_Dialog: DialogPtr;    (* nested dialog box for selections *)			PS: array[1..Max_Axes] of StringX;    (* pick list string *)			Mouse_Pt: Point;                       (* mouse click location *)			Yes_Box: Rect;                         (* Okay button location *)			No_Box: Rect;                         (* Cancel button loaction *)			Mouse_Event: EventRecord;              (* mouse click event *)			I: integer;	begin		Init_Dialog := GetNewDialog(AmapId, nil, Pointer(-1));		SetPort(Init_Dialog);                   (* for local coordinates *)		GetDItem(Init_DIalog, Ok, The_Type, The_ItemHdl, Yes_Box);		GetDItem(Init_Dialog, Cancel, The_Type, The_ItemHdl, No_Box);		GetDItem(Init_Dialog, AI - 1, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, 'AXIS    ID     DESCRIPTION');		The_Text := '';{$IFC THINK_PASCAL}		for I := 1 to Max_Axes do			with AA[I].A do				PS[I] := Concat(Id, '       ', IntToStr(No), '       ', Name);		for I := 1 to Max_Axes do			begin				while Length(PS[I]) < MaxCh do					PS[I] := Concat(PS[I], ' ');				PS[I][MaxCh] := CR;				The_Text := Concat(The_Text, PS[I]);			end;{$ELSEC}		for I := 1 to Max_Axes do			with AA[I].A do				PS[I] := Id + '       ' + IntToStr(No) + '       ' + Name;		for I := 1 to Max_Axes do			begin				while Length(PS[I]) < MaxCh do					PS[I] := PS[I] + ' ';				PS[I][MaxCh] := CR;				The_Text := The_Text + PS[I];			end;{$ENDC}		GetDItem(Init_Dialog, AI, The_Type, The_TextHdl, The_ItemBox);		SetIText(The_TextHdl, The_Text);		SelIText(Init_Dialog, AI, 0, Length(PS[1]));		ShowWindow(WindowPtr(Init_Dialog));		I := 1;		repeat			repeat				repeat				until GetNextEvent(mDownMask, Mouse_Event);			until Mouse_Event.What = MouseDown;			SelIText(Init_Dialog, AI, 0, 0);			ShowWindow(Init_Dialog);			GlobalToLocal(Mouse_Event.Where);        (* for local coordinates *)			Mouse_Pt := Mouse_Event.Where;			if PtInRect(Mouse_Pt, The_ItemBox) then				I := Round(0.5 + 8.0 * (Mouse_Pt.V - The_ItemBox.Top) / (The_ItemBox.Bottom - The_ItemBox.Top));			if I < 1 then				I := 1			else if I > Max_Axes then				I := Max_Axes;			SelIText(Init_Dialog, AI, (I - 1) * Length(PS[I]), I * Length(PS[I]));			ShowWindow(Init_Dialog);		until (PtInRect(Mouse_Pt, Yes_Box)) or (PtInRect(Mouse_Pt, No_Box));		if PtInRect(Mouse_Pt, Yes_Box) then			begin				The_Dialog := GetNewDialog(AmapId2, nil, Pointer(-1));				with AA[I] do					begin						The_Text := A.Id;						GetDItem(The_Dialog, AI, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						The_Text := IntToStr(A.No);						GetDItem(The_Dialog, AM, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						The_Text := A.Name;						GetDItem(The_Dialog, AN, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						SelItext(The_Dialog, AN, 0, Length(The_Text));					end;				DoDefaultButton(The_Dialog);				repeat					ModalDialog(nil, The_Item);					GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);					if The_Type = TextItem then						begin							GetIText(The_ItemHdl, The_Text);							with AA[I] do								case The_Item of									AI: 										A.Id := The_Text;									AM: 										A.No := StrToInt(The_Text);									AN: 										A.Name := The_Text;								end;						end;				until (The_Type = BtnItem);				DisposDialog(The_Dialog);			end;		DisposDialog(Init_Dialog);	end;(* Dialog for User Units. *)	procedure Get_User_Units_Options;		const			UX = 4;                   (* User Axis item *)			UU = 6;                   (* User Unit item *)			UK = 8;                   (* User K-scaler item *)			UD = 10;                  (* User 1/K-scaler item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)			QQ: string[2];            (* axis Id *)			Axis_Okay: Boolean;        (* axis Id okay *)			J: Integer;                (* temp axis index *)	begin		The_Dialog := GetNewDialog(UnitId, nil, Pointer(-1));		I := 1;		QQ := AA[I].A.Id;		Axis_Okay := True;		repeat			if Axis_Okay then				with AA[I] do					begin						The_Text := A.Id;						GetDItem(The_Dialog, UX, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						The_Text := K.Units;						GetDItem(The_Dialog, UU, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						SelItext(The_Dialog, UU, 0, Length(The_Text));						The_Text := RealToStr(K.Kscale, K.DP);						GetDItem(The_Dialog, UK, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						The_Text := RealToStr(1.0 / K.Kscale, K.DP);						GetDItem(The_Dialog, UD, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						Axis_Okay := False;					end;			DoDefaultButton(The_Dialog);			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					with AA[I] do						case The_Item of							UU: 								K.Units := The_Text;							UK: 								K.Kscale := StrToReal(The_Text);							UD: 								K.Kscale := 1.0 / StrToReal(The_Text);							UX: 								QQ := The_Text;						end;				end;			if (The_Type = BtnItem) and (The_Item = Ok) then				begin					Case_Axis(QQ, Axis_Okay, J);					if Axis_Okay then						I := J;				end;		until (The_Type = BtnItem) and (The_Item = Cancel);		DisposDialog(The_Dialog);	end;(* Dialog for Motor Speeds. *)	procedure Get_Motor_Profile_Options;		const			MX = 4;                   (* Motor item *)			ML = 6;                   (* Low Speed item *)			MH = 8;                   (* High Speed item *)			MR = 10;                  (* Ramp Count item *)		var			The_TextHdl: Handle;       (* Text item handle *)			The_Text: Str255;          (* user text *)			QQ: string[2];            (* axis Id *)			Axis_Okay: Boolean;        (* axis Id okay *)			J: Integer;                (* temp axis index *)	begin		The_Dialog := GetNewDialog(MspdId, nil, Pointer(-1));		I := 1;		QQ := AA[I].A.Id;		Axis_Okay := True;		repeat			if Axis_Okay then				with AA[I] do					begin						The_Text := A.Id;						GetDItem(The_Dialog, MX, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						The_Text := RealToStr(R.Min_LowSpd, 0);						GetDItem(The_Dialog, ML, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						SelItext(The_Dialog, ML, 0, Length(The_Text));						The_Text := RealToStr(R.Max_HighSpd, 0);						GetDItem(The_Dialog, MH, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						The_Text := RealToStr(R.Max_RampCnt, 0);						GetDItem(The_Dialog, MR, The_Type, The_TextHdl, The_ItemBox);						SetIText(The_TextHdl, The_Text);						Axis_Okay := False;					end;			DoDefaultButton(The_Dialog);			ModalDialog(nil, The_Item);			GetDItem(The_Dialog, The_Item, The_Type, The_ItemHdl, The_ItemBox);			if The_Type = TextItem then				begin					GetIText(The_ItemHdl, The_Text);					with AA[I] do						case The_Item of							ML: 								R.Min_LowSpd := StrToReal(The_Text);							MH: 								R.Max_HighSpd := StrToReal(The_Text);							MR: 								R.Max_RampCnt := StrToReal(The_Text);							MX: 								QQ := The_Text;						end;				end;			if (The_Type = BtnItem) and (The_Item = Ok) then				begin					Case_Axis(QQ, Axis_Okay, J);					if Axis_Okay then						I := J;				end;		until (The_Type = BtnItem) and (The_Item = Cancel);		DisposDialog(The_Dialog);	end;(***** Utilities *****)(* Install Axis Map. *)	procedure Do_Axis_Map;		var			S: string;			I: integer;	begin		DrawStr('Axis Map...');		Drawln;		Drawln;		for I := 1 to Max_Axes do			with AA[I].A do				begin{$IFC THINK_PASCAL}					S := Concat(Id, ' ', IntToStr(No), ' ', Name);{$ELSEC}					S := Id + ' ' + IntToStr(No) + ' ' + Name;{$ENDC}					DrawStr(S);					Drawln;				end;		Get_Axis_Map_Options;	end;(* Install User Units. *)	procedure Do_User_Units;		var			S: Str255;			I: integer;	begin		DrawStr('User Units...');		Drawln;		Drawln;		for I := 1 to Max_Axes do			with AA[I].K do				begin{$IFC THINK_PASCAL}					S := Concat(AA[I].A.Id, ' ', RealToStr(Kscale, DP), ' ', IntToStr(DP), ' ', Units);{$ELSEC}					S := AA[I].A.Id + ' ';					S := S + RealToStr(Kscale, DP) + ' ' + IntToStr(DP) + ' ' + Units;{$ENDC}					DrawStr(S);					Drawln;				end;		Get_User_Units_Options;	end;(* Install Motor Speed Profiles. *)	procedure Do_Motor_Profiles;		var			S: Str255;			I: integer;	begin		DrawStr('Motor Speeds...');		Drawln;		Drawln;		for I := 1 to Max_Axes do			with AA[I].R do				begin{$IFC THINK_PASCAL}					S := Concat(AA[I].A.Id, ' ');					if AccelSt then						S := Concat(S, 'Accel / Decel  ')					else						S := Concat(S, 'Constant Speed ');					S := Concat(S, RealToStr(Max_Speed, 0), ' ', RealToStr(Min_LowSpd, 0), ' ', RealToStr(Max_HighSpd, 0), ' ', RealToStr(Max_RampCnt, 0));{$ELSEC}					S := AA[I].A.Id + ' ';					if AccelSt then						S := S + 'Accel / Decel  '					else						S := S + 'Constant Speed ';					S := S + RealToStr(Max_Speed, 0) + ' ' + RealToStr(Min_LowSpd, 0) + ' ' + RealToStr(Max_HighSpd, 0) + ' ' + RealToStr(Max_RampCnt, 0);{$ENDC}					DrawStr(S);					Drawln;				end;		Get_Motor_Profile_Options;	end;End.